<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SilentStacks Enhanced - Comprehensive API & Clinical Integration</title>
    <style>
        /* Base from v1.2 with enhancements for API features */
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --primary-color: #0066cc;
            --secondary-color: #6c757d;
            --success-color: #228b22;
            --danger-color: #dc3545;
            --warning-color: #ff6600;
            --info-color: #17a2b8;
            --clinical-color: #8e44ad;
            --mesh-color: #6f42c1;
            --nct-color: #e74c3c;
            --user-tag-color: #20c997;
            
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-card: #ffffff;
            
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --text-muted: #868e96;
            
            --border-color: #dee2e6;
            --border-radius: 4px;
            --shadow-sm: 0 1px 2px rgba(0,0,0,0.05);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.1);
        }

        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-card: #2d2d2d;
            --text-primary: #ffffff;
            --text-secondary: #adb5bd;
            --text-muted: #868e96;
            --border-color: #495057;
        }

        body {
            font-family: 'Reddit Sans', 'Inter', 'SF Pro Display', 'Segoe UI Variable', 'Segoe UI', system-ui, sans-serif;
            font-size: 16px;
            line-height: 1.6;
            color: var(--text-primary);
            background-color: var(--bg-primary);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px 0;
            border-bottom: 2px solid var(--border-color);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 5px;
        }

        .header p {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        /* Navigation */
        .nav-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--border-color);
            padding: 10px 0 0 0;
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .nav-tabs::-webkit-scrollbar { display: none; }

        .nav-tab {
            padding: 10px 20px;
            border: none;
            background: none;
            font-size: 1rem;
            font-weight: 500;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
        }

        .nav-tab:hover { color: var(--primary-color); }
        .nav-tab.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }

        /* Sections */
        .section {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .section.active { display: block; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Enhanced Form */
        .request-form {
            max-width: 800px;
        }

        .form-group {
            margin-bottom: 24px;
            position: relative;
        }

        .form-label {
            display: flex;
            align-items: baseline;
            font-weight: 600;
            font-size: 1rem;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .form-control {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 1rem;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: all 0.3s ease;
            min-height: 44px;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0, 102, 204, 0.2);
        }

        /* Enhanced Input with Button */
        .input-with-button.enhanced {
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius);
            overflow: hidden;
            transition: all 0.3s ease;
            display: flex;
        }

        .input-with-button.enhanced:focus-within {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0, 102, 204, 0.2);
        }

        .input-with-button.enhanced input {
            flex: 1;
            border: none;
            border-radius: 0;
            padding: 12px 16px;
        }

        .input-with-button.enhanced input:focus { box-shadow: none; }

        .lookup-btn {
            border: none;
            border-radius: 0;
            min-width: 120px;
            padding: 12px 16px;
            background: var(--primary-color);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .lookup-btn:hover { background: #0056b3; }
        .lookup-btn:disabled { opacity: 0.6; cursor: not-allowed; }

        /* Request Cards */
        .request-card {
            background: var(--bg-card);
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: var(--shadow-sm);
            transition: all 0.3s ease;
            position: relative;
        }

        .request-card:hover {
            box-shadow: var(--shadow-md);
            border-color: var(--primary-color);
        }

        .request-card.clinical-trial {
            border-left: 4px solid var(--clinical-color);
        }

        .request-card.follow-up-due {
            border-left: 4px solid var(--warning-color);
        }

        .nlm-citation {
            font-family: 'Times New Roman', serif;
            font-size: 0.95rem;
            line-height: 1.3;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .nct-info {
            background: rgba(231, 76, 60, 0.1);
            border: 1px solid var(--nct-color);
            border-radius: var(--border-radius);
            padding: 8px 12px;
            margin: 8px 0;
            font-size: 0.9rem;
        }

        .nct-title {
            font-weight: 600;
            color: var(--nct-color);
            margin-bottom: 4px;
        }

        .nct-status {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .nct-status.recruiting { background: #28a745; color: white; }
        .nct-status.completed { background: #6c757d; color: white; }
        .nct-status.terminated { background: #dc3545; color: white; }
        .nct-status.active { background: #17a2b8; color: white; }

        /* Tags */
        .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin: 8px 0;
        }

        .tag {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .tag:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .tag.mesh {
            background: var(--mesh-color);
            color: white;
        }

        .tag.nct {
            background: var(--nct-color);
            color: white;
        }

        .tag.user {
            background: var(--user-tag-color);
            color: white;
        }

        .tag.selected {
            box-shadow: 0 0 0 2px var(--primary-color);
        }

        /* Table */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            background: var(--bg-card);
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--shadow-sm);
            margin-bottom: 20px;
        }

        .data-table th {
            background: var(--primary-color);
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        .data-table th:hover {
            background: #0056b3;
        }

        .data-table th.sorted-asc::after {
            content: ' ↑';
            color: #fff;
        }

        .data-table th.sorted-desc::after {
            content: ' ↓';
            color: #fff;
        }

        .data-table td {
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
            vertical-align: top;
        }

        .data-table tbody tr:hover {
            background: var(--bg-secondary);
        }

        /* Follow-up indicators */
        .follow-up-due {
            background: var(--warning-color);
            color: white;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .follow-up-ok {
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        /* Batch Processing */
        .batch-section {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-sm);
        }

        .batch-textarea {
            width: 100%;
            min-height: 150px;
            padding: 15px;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius);
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            background: var(--bg-primary);
            color: var(--text-primary);
            resize: vertical;
        }

        .batch-progress {
            margin: 15px 0;
            padding: 15px;
            background: var(--bg-secondary);
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary-color);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            font-size: 0.9rem;
            color: var(--text-secondary);
            text-align: center;
        }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            border: none;
            border-radius: var(--border-radius);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 44px;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: #0056b3;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background-color: var(--secondary-color);
            color: white;
        }

        .btn-success {
            background-color: var(--success-color);
            color: white;
        }

        .btn-danger {
            background-color: var(--danger-color);
            color: white;
        }

        /* Status Messages */
        .status-message {
            margin-top: 15px;
            padding: 10px;
            border-radius: var(--border-radius);
            display: none;
        }

        .status-message.success {
            background-color: rgba(34, 139, 34, 0.1);
            color: var(--success-color);
            border: 1px solid var(--success-color);
            display: block;
        }

        .status-message.error {
            background-color: rgba(220, 53, 69, 0.1);
            color: var(--danger-color);
            border: 1px solid var(--danger-color);
            display: block;
        }

        .status-message.loading {
            background-color: rgba(0, 102, 204, 0.1);
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
            display: block;
        }

        /* Fieldset styling */
        .fieldset-enhanced {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            background: var(--bg-card);
        }

        legend {
            font-weight: 700;
            color: var(--text-primary);
            padding: 0 16px;
            font-size: 1.1rem;
        }

        /* Loading spinner */
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Form help */
        .form-help {
            display: block;
            margin-top: 6px;
            color: var(--text-muted);
            font-size: 0.875rem;
            line-height: 1.4;
        }

        /* Connection status */
        #connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 10000;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 0.75rem;
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        /* Filter controls */
        .filter-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-controls input,
        .filter-controls select {
            min-width: 150px;
        }

        /* Auto-filled indicator */
        .auto-filled {
            background: rgba(40, 167, 69, 0.1) !important;
            border-color: var(--success-color) !important;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .header h1 { font-size: 2rem; }
            .input-with-button.enhanced { flex-direction: column; }
            .input-with-button.enhanced .lookup-btn { margin: 8px 0 0 0; }
            .filter-controls { flex-direction: column; align-items: stretch; }
            .data-table { font-size: 0.9rem; }
            .data-table th, .data-table td { padding: 8px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <h1>SilentStacks Enhanced</h1>
            <p>Comprehensive API Integration with Cross-Population & Clinical Trials</p>
        </header>

        <!-- Connection Status -->
        <div id="connection-status">🌐 Online</div>

        <!-- Navigation -->
        <nav class="nav-tabs">
            <button class="nav-tab active" data-section="dashboard">Dashboard</button>
            <button class="nav-tab" data-section="add-request">Add Request</button>
            <button class="nav-tab" data-section="bulk-processing">Bulk Processing</button>
            <button class="nav-tab" data-section="all-requests">All Requests</button>
            <button class="nav-tab" data-section="import-export">Import/Export</button>
            <button class="nav-tab" data-section="settings">Settings</button>
        </nav>

        <!-- Main Content -->
        <main>
            <!-- Dashboard -->
            <section id="dashboard" class="section active">
                <h2>Dashboard</h2>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px;">
                    <div style="background: var(--bg-card); padding: 20px; border-radius: var(--border-radius); border: 1px solid var(--border-color); text-align: center;">
                        <h3 style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 10px;">Total Requests</h3>
                        <p style="font-size: 2.5rem; font-weight: 700; color: var(--primary-color);" id="total-requests">0</p>
                    </div>
                    <div style="background: var(--bg-card); padding: 20px; border-radius: var(--border-radius); border: 1px solid var(--border-color); text-align: center;">
                        <h3 style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 10px;">Clinical Trials</h3>
                        <p style="font-size: 2.5rem; font-weight: 700; color: var(--clinical-color);" id="clinical-trials">0</p>
                    </div>
                    <div style="background: var(--bg-card); padding: 20px; border-radius: var(--border-radius); border: 1px solid var(--border-color); text-align: center;">
                        <h3 style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 10px;">Follow-ups Due</h3>
                        <p style="font-size: 2.5rem; font-weight: 700; color: var(--warning-color);" id="followups-due">0</p>
                    </div>
                    <div style="background: var(--bg-card); padding: 20px; border-radius: var(--border-radius); border: 1px solid var(--border-color); text-align: center;">
                        <h3 style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 10px;">Fulfilled</h3>
                        <p style="font-size: 2.5rem; font-weight: 700; color: var(--success-color);" id="fulfilled-requests">0</p>
                    </div>
                </div>
                
                <h3>Recent Requests</h3>
                <div id="recent-requests"></div>
            </section>

            <!-- Add Request -->
            <section id="add-request" class="section">
                <h2>Add New Request</h2>
                <form id="request-form" class="request-form">
                    <!-- Identifiers -->
                    <fieldset class="fieldset-enhanced">
                        <legend>🔍 Identifiers & Cross-Population</legend>
                        
                        <div class="form-group">
                            <label for="pmid" class="form-label">PMID (PubMed ID)</label>
                            <div class="input-with-button enhanced">
                                <input type="text" id="pmid" name="pmid" class="form-control" placeholder="e.g., 32658653" pattern="[0-9]+">
                                <button type="button" id="lookup-pmid" class="lookup-btn">🔍 Lookup</button>
                            </div>
                            <small class="form-help">Auto-populates citation, DOI, and searches for NCT IDs</small>
                        </div>

                        <div class="form-group">
                            <label for="doi" class="form-label">DOI (Digital Object Identifier)</label>
                            <div class="input-with-button enhanced">
                                <input type="text" id="doi" name="doi" class="form-control" placeholder="e.g., 10.1038/nature12373">
                                <button type="button" id="lookup-doi" class="lookup-btn">🔗 Lookup</button>
                            </div>
                            <small class="form-help">Auto-populates citation and attempts PMID resolution</small>
                        </div>

                        <div class="form-group">
                            <label for="nct-id" class="form-label">Clinical Trial ID (NCT)</label>
                            <div class="input-with-button enhanced">
                                <input type="text" id="nct-id" name="nct-id" class="form-control" placeholder="e.g., NCT04280549">
                                <button type="button" id="lookup-nct" class="lookup-btn">🧪 Lookup</button>
                            </div>
                            <small class="form-help">Fetches trial details and linked publications</small>
                        </div>

                        <div class="form-group">
                            <label for="docline" class="form-label">DOCLINE Request Number</label>
                            <input type="text" id="docline" name="docline" class="form-control" placeholder="e.g., 138ABC123">
                            <small class="form-help">ILL tracking number for existing DOCLINE requests</small>
                        </div>
                    </fieldset>

                    <!-- Publication Details -->
                    <fieldset class="fieldset-enhanced">
                        <legend>📚 Publication Details</legend>
                        
                        <div class="form-group">
                            <label for="title" class="form-label">Publication Title *</label>
                            <input type="text" id="title" name="title" class="form-control" required placeholder="Complete title of the requested publication">
                        </div>

                        <div class="form-group">
                            <label for="authors" class="form-label">Author(s)</label>
                            <input type="text" id="authors" name="authors" class="form-control" placeholder="Smith J, Johnson A, et al.">
                        </div>

                        <div class="form-group">
                            <label for="journal" class="form-label">Journal/Publication Source</label>
                            <input type="text" id="journal" name="journal" class="form-control" placeholder="Journal of Medical Research">
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
                            <div class="form-group">
                                <label for="year" class="form-label">Year</label>
                                <input type="number" id="year" name="year" class="form-control" min="1900" max="2026" placeholder="2025">
                            </div>
                            <div class="form-group">
                                <label for="volume" class="form-label">Volume</label>
                                <input type="text" id="volume" name="volume" class="form-control" placeholder="30">
                            </div>
                            <div class="form-group">
                                <label for="pages" class="form-label">Pages</label>
                                <input type="text" id="pages" name="pages" class="form-control" placeholder="123-130">
                            </div>
                        </div>
                    </fieldset>

                    <!-- Request Management -->
                    <fieldset class="fieldset-enhanced">
                        <legend>📋 Request Management</legend>
                        
                        <div class="form-group">
                            <label for="patron-email" class="form-label">Patron Email</label>
                            <input type="email" id="patron-email" name="patronEmail" class="form-control" placeholder="patron@example.com">
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                            <div class="form-group">
                                <label for="priority" class="form-label">Priority *</label>
                                <select id="priority" name="priority" class="form-control" required>
                                    <option value="">Select Priority...</option>
                                    <option value="urgent">🚨 Urgent - Critical Patient Care</option>
                                    <option value="rush">⚡ Rush - Expedited Timeline</option>
                                    <option value="normal">📋 Normal - Standard Processing</option>
                                </select>
                            </div>

                            <div class="form-group">
                                <label for="status" class="form-label">Status</label>
                                <select id="status" name="status" class="form-control">
                                    <option value="pending">Pending - Awaiting Processing</option>
                                    <option value="in-progress">In Progress - Actively Working</option>
                                    <option value="fulfilled">Fulfilled - Successfully Completed</option>
                                    <option value="cancelled">Cancelled - Request Withdrawn</option>
                                </select>
                            </div>
                        </div>

                        <div class="form-group">
                            <label for="user-tags" class="form-label">Custom Tags</label>
                            <input type="text" id="user-tags" name="userTags" class="form-control" placeholder="e.g., cardiology, review, systematic">
                            <small class="form-help">Enter custom tags separated by commas</small>
                        </div>

                        <div class="form-group">
                            <label for="notes" class="form-label">Additional Notes</label>
                            <textarea id="notes" name="notes" rows="3" class="form-control" placeholder="Any special instructions or notes..."></textarea>
                        </div>
                    </fieldset>

                    <!-- Auto-populated tags display -->
                    <div id="tags-display" style="display: none;">
                        <h4>🏷️ Auto-Generated Tags</h4>
                        <div id="mesh-tags" class="tags-container"></div>
                        <div id="nct-tags" class="tags-container"></div>
                    </div>

                    <div style="display: flex; gap: 15px; margin-top: 30px;">
                        <button type="submit" class="btn btn-primary">💾 Save Request</button>
                        <button type="button" class="btn btn-secondary" id="clear-form">🗑️ Clear Form</button>
                    </div>
                </form>

                <div id="lookup-status" class="status-message"></div>
            </section>

            <!-- Bulk Processing -->
            <section id="bulk-processing" class="section">
                <h2>📋 Bulk Processing & Cross-Population</h2>
                
                <div class="batch-section">
                    <h3>🚀 Bulk Identifier Processing</h3>
                    <p>Enter any combination of PMIDs, DOIs, or NCT IDs. Each will be cross-populated with related data.</p>
                    
                    <div class="form-group">
                        <label for="bulk-identifiers" class="form-label">Identifiers (Mixed Format Supported)</label>
                        <textarea id="bulk-identifiers" class="batch-textarea" placeholder="Examples of supported formats:

PMIDs: 32658653, 34226022, 35123456
DOIs: 10.1038/nature12373, 10.1056/NEJMoa2034577
NCT IDs: NCT04280549, NCT03875612

Mixed format:
32658653
10.1038/nature12373
NCT04280549
34226022

Or paste from any source - the system will auto-detect and normalize"></textarea>
                        <small class="form-help">Supports PMIDs (6-8 digits), DOIs (10.xxxx/xxx), and NCT IDs (NCTxxxxxxxx)</small>
                    </div>

                    <div class="form-group">
                        <input type="file" id="bulk-file" accept=".txt,.json,.csv" class="form-control">
                        <small class="form-help">Upload text, JSON, or CSV file containing identifiers</small>
                    </div>

                    <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                        <button type="button" class="btn btn-primary" id="process-bulk">🚀 Process All Identifiers</button>
                        <button type="button" class="btn btn-secondary" id="clear-bulk">🗑️ Clear</button>
                        <button type="button" class="btn btn-danger" id="cancel-bulk" style="display: none;">⏹️ Cancel Processing</button>
                    </div>

                    <div id="bulk-progress" class="batch-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress-fill"></div>
                        </div>
                        <div class="progress-text" id="progress-text">Processing...</div>
                    </div>

                    <div id="bulk-status" class="status-message"></div>
                </div>

                <div class="batch-section">
                    <h3>📊 Processing Results</h3>
                    <div id="bulk-results"></div>
                </div>
            </section>

            <!-- All Requests -->
            <section id="all-requests" class="section">
                <h2>📋 All Requests</h2>
                
                <div class="filter-controls">
                    <input type="text" id="search-requests" placeholder="Search all fields..." class="form-control">
                    <select id="filter-status" class="form-control">
                        <option value="">All Statuses</option>
                        <option value="pending">Pending</option>
                        <option value="in-progress">In Progress</option>
                        <option value="fulfilled">Fulfilled</option>
                        <option value="cancelled">Cancelled</option>
                    </select>
                    <select id="filter-priority" class="form-control">
                        <option value="">All Priorities</option>
                        <option value="urgent">Urgent</option>
                        <option value="rush">Rush</option>
                        <option value="normal">Normal</option>
                    </select>
                    <select id="filter-followup" class="form-control">
                        <option value="">All Follow-ups</option>
                        <option value="due">Due</option>
                        <option value="not-due">Not Due</option>
                    </select>
                    <button class="btn btn-secondary" id="clear-filters">Clear Filters</button>
                </div>

                <div id="selected-tags" class="tags-container" style="margin-bottom: 15px;"></div>
                
                <!-- Table View -->
                <div style="overflow-x: auto;">
                    <table class="data-table" id="requests-table">
                        <thead>
                            <tr>
                                <th data-sort="docline">DOCLINE #</th>
                                <th data-sort="pmid">PMID</th>
                                <th data-sort="citation">NLM Citation</th>
                                <th data-sort="patronEmail">Patron Email</th>
                                <th data-sort="priority">Priority</th>
                                <th data-sort="status">Status</th>
                                <th data-sort="followUpAt">Follow-Up</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="requests-table-body">
                        </tbody>
                    </table>
                </div>

                <!-- Card View Toggle -->
                <div style="margin: 20px 0;">
                    <button class="btn btn-secondary" id="toggle-view">🔄 Switch to Card View</button>
                </div>

                <div id="request-cards" style="display: none;"></div>
            </section>

            <!-- Import/Export -->
            <section id="import-export" class="section">
                <h2>📤📥 Import/Export Data</h2>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                    <div style="background: var(--bg-card); border: 1px solid var(--border-color); border-radius: var(--border-radius); padding: 20px;">
                        <h3>📤 Export Data</h3>
                        <p>Download your requests with full metadata</p>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 15px;">
                            <button id="export-csv" class="btn btn-primary">📊 Export CSV</button>
                            <button id="export-json" class="btn btn-primary">🔧 Export JSON</button>
                            <button id="export-nlm" class="btn btn-success">📚 Export NLM Citations</button>
                        </div>
                    </div>

                    <div style="background: var(--bg-card); border: 1px solid var(--border-color); border-radius: var(--border-radius); padding: 20px;">
                        <h3>📥 Import Data</h3>
                        <p>Upload CSV, JSON, or text files</p>
                        <input type="file" id="import-file" accept=".csv,.json,.txt" class="form-control" style="margin: 15px 0;">
                        <div id="import-status" class="status-message"></div>
                    </div>
                </div>
            </section>

            <!-- Settings -->
            <section id="settings" class="section">
                <h2>⚙️ Settings</h2>
                
                <form id="settings-form" style="max-width: 600px;">
                    <div class="form-group">
                        <label for="followup-days" class="form-label">Follow-up Days</label>
                        <input type="number" id="followup-days" min="1" max="30" value="5" class="form-control">
                        <small class="form-help">Mark requests as needing follow-up after this many days</small>
                    </div>

                    <div class="form-group">
                        <label for="theme" class="form-label">Theme</label>
                        <select id="theme" class="form-control">
                            <option value="light">Light</option>
                            <option value="dark">Dark</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="api-key" class="form-label">PubMed API Key (Optional)</label>
                        <input type="text" id="api-key" placeholder="Enter your NCBI API key" class="form-control">
                        <small class="form-help">Provides higher rate limits for PubMed lookups</small>
                    </div>

                    <div class="form-group">
                        <label for="crossref-email" class="form-label">CrossRef Email (Optional)</label>
                        <input type="email" id="crossref-email" placeholder="your@email.com" class="form-control">
                        <small class="form-help">Enables polite pool access for DOI lookups</small>
                    </div>

                    <button type="submit" class="btn btn-primary">💾 Save Settings</button>
                </form>
            </section>
        </main>
    </div>

    <script>
        // SilentStacks Enhanced - Comprehensive Implementation
        (() => {
            // Current date for follow-up calculations (August 10, 2025)
            const CURRENT_DATE = new Date('2025-08-10T00:00:00-04:00'); // Eastern Time
            
            // State management
            let state = {
                requests: [],
                settings: {
                    followupDays: 5,
                    theme: 'light',
                    apiKey: '',
                    crossrefEmail: ''
                },
                ui: {
                    currentSection: 'dashboard',
                    isOnline: navigator.onLine,
                    viewMode: 'table', // 'table' or 'cards'
                    selectedTags: new Set(),
                    sortField: 'createdAt',
                    sortDirection: 'desc'
                },
                processing: {
                    isActive: false,
                    canCancel: false
                }
            };

            // API rate limiting
            const API_DELAY = 1000; // 1 second between calls
            let lastApiCall = 0;

            // Utility functions
            const utils = {
                generateId: () => Date.now().toString(36) + Math.random().toString(36).substr(2),
                
                sanitize: (str) => str ? String(str).replace(/[<>]/g, '') : '',
                
                delay: (ms) => new Promise(resolve => setTimeout(resolve, ms)),
                
                safeValue: (value) => value || 'N/A',
                
                normalizeIdentifiers: (text) => {
                    if (!text) return [];
                    
                    // Clean and normalize input
                    const cleanText = text
                        .replace(/[\r\n]+/g, ' ')
                        .replace(/[,;]+/g, ' ')
                        .replace(/\s+/g, ' ')
                        .trim();
                    
                    const identifiers = [];
                    
                    // Extract PMIDs (6-8 digits)
                    const pmidMatches = cleanText.match(/\b\d{6,8}\b/g) || [];
                    pmidMatches.forEach(pmid => {
                        identifiers.push({ type: 'pmid', value: pmid });
                    });
                    
                    // Extract DOIs
                    const doiMatches = cleanText.match(/10\.\d{4,}\/[^\s]+/g) || [];
                    doiMatches.forEach(doi => {
                        identifiers.push({ type: 'doi', value: doi });
                    });
                    
                    // Extract NCT IDs
                    const nctMatches = cleanText.match(/NCT\d{8}/gi) || [];
                    nctMatches.forEach(nct => {
                        identifiers.push({ type: 'nct', value: nct.toUpperCase() });
                    });
                    
                    // Remove duplicates
                    const seen = new Set();
                    return identifiers.filter(id => {
                        const key = `${id.type}:${id.value}`;
                        if (seen.has(key)) return false;
                        seen.add(key);
                        return true;
                    });
                },

                async respectRateLimit() {
                    const now = Date.now();
                    const timeSinceLastCall = now - lastApiCall;
                    if (timeSinceLastCall < API_DELAY) {
                        await this.delay(API_DELAY - timeSinceLastCall);
                    }
                    lastApiCall = Date.now();
                },

                calculateFollowUpDate(createdAt, followupDays = 5) {
                    const created = new Date(createdAt);
                    const followUp = new Date(created);
                    followUp.setDate(followUp.getDate() + followupDays);
                    return followUp;
                },

                isFollowUpDue(followUpAt, status) {
                    if (status === 'fulfilled' || status === 'cancelled') return false;
                    return new Date(followUpAt) <= CURRENT_DATE;
                },

                formatNLMCitation(metadata) {
                    const parts = [];
                    
                    // Authors (limit to 6, add et al if more)
                    if (metadata.authors) {
                        const authorList = metadata.authors.split(/[;,]/).map(a => a.trim()).slice(0, 6);
                        const authorsText = authorList.join(', ');
                        const etAl = metadata.authors.split(/[;,]/).length > 6 ? ', et al' : '';
                        parts.push(`${authorsText}${etAl}.`);
                    }
                    
                    // Title
                    if (metadata.title) {
                        const title = metadata.title.endsWith('.') ? metadata.title : `${metadata.title}.`;
                        parts.push(title);
                    }
                    
                    // Journal with volume/issue/pages
                    if (metadata.journal) {
                        let journalPart = metadata.journal;
                        if (metadata.year) journalPart += `. ${metadata.year}`;
                        if (metadata.volume) {
                            journalPart += `;${metadata.volume}`;
                            if (metadata.issue) journalPart += `(${metadata.issue})`;
                            if (metadata.pages) journalPart += `:${metadata.pages}`;
                        }
                        journalPart += '.';
                        parts.push(journalPart);
                    }
                    
                    // PMID
                    if (metadata.pmid) {
                        parts.push(`PMID: ${metadata.pmid}.`);
                    }
                    
                    // DOI
                    if (metadata.doi) {
                        parts.push(`doi: ${metadata.doi}.`);
                    }
                    
                    return parts.join(' ').replace(/\s+/g, ' ').trim();
                },

                extractNCTFromText(text) {
                    if (!text) return [];
                    const nctMatches = text.match(/NCT\d{8}/gi) || [];
                    return [...new Set(nctMatches.map(nct => nct.toUpperCase()))];
                }
            };

            // Enhanced API service with cross-population
            const apiService = {
                async fetchPubMed(pmid) {
                    await utils.respectRateLimit();
                    
                    try {
                        const keyParam = state.settings.apiKey ? `&api_key=${state.settings.apiKey}` : '';
                        
                        // Step 1: Get basic metadata from ESummary
                        const summaryUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?db=pubmed&id=${pmid}&retmode=json${keyParam}`;
                        const summaryResponse = await fetch(summaryUrl);
                        
                        if (!summaryResponse.ok) {
                            throw new Error(`PubMed API error: ${summaryResponse.status}`);
                        }
                        
                        const summaryData = await summaryResponse.json();
                        
                        if (summaryData.error || !summaryData.result[pmid]) {
                            throw new Error(`PMID ${pmid} not found`);
                        }
                        
                        const record = summaryData.result[pmid];
                        
                        // Enhanced metadata extraction
                        const metadata = {
                            pmid: pmid,
                            title: this.cleanTitle(record.title || ''),
                            authors: this.formatAuthors(record.authors || []),
                            journal: this.formatJournal(record),
                            year: this.extractYear(record.pubdate || ''),
                            volume: record.volume || '',
                            issue: record.issue || '',
                            pages: record.pages || '',
                            doi: '',
                            abstract: '',
                            meshTerms: [],
                            publicationTypes: record.pubtype || [],
                            source: 'pubmed'
                        };
                        
                        // Step 2: Get detailed info from EFetch for DOI, abstract, and MeSH
                        try {
                            await utils.respectRateLimit();
                            const fetchUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=pubmed&id=${pmid}&retmode=xml${keyParam}`;
                            const xmlResponse = await fetch(fetchUrl);
                            
                            if (xmlResponse.ok) {
                                const xmlText = await xmlResponse.text();
                                const parser = new DOMParser();
                                const doc = parser.parseFromString(xmlText, 'application/xml');
                                
                                // Extract DOI
                                const doiNode = doc.querySelector('ArticleId[IdType="doi"]') || 
                                               doc.querySelector('ELocationID[EIdType="doi"]');
                                if (doiNode) {
                                    metadata.doi = doiNode.textContent.trim();
                                }
                                
                                // Extract abstract
                                const abstractNode = doc.querySelector('AbstractText');
                                if (abstractNode) {
                                    metadata.abstract = abstractNode.textContent.trim();
                                }
                                
                                // Extract MeSH terms
                                const meshNodes = doc.querySelectorAll('MeshHeading DescriptorName');
                                metadata.meshTerms = Array.from(meshNodes).map(node => ({
                                    term: node.textContent.trim(),
                                    majorTopic: node.getAttribute('MajorTopicYN') === 'Y',
                                    source: 'mesh'
                                }));
                                
                                // Check for clinical trial indicators and extract NCT IDs
                                metadata.isClinicalTrial = this.detectClinicalTrial(doc, metadata);
                                metadata.nctIds = utils.extractNCTFromText(`${metadata.title} ${metadata.abstract}`);
                            }
                        } catch (xmlError) {
                            console.warn('Failed to fetch detailed XML data:', xmlError);
                        }
                        
                        // Step 3: Cross-populate with DOI data if available
                        if (metadata.doi) {
                            try {
                                const crossrefData = await this.fetchCrossRef(metadata.doi);
                                // Merge data, preferring PubMed for conflicts
                                metadata.volume = metadata.volume || crossrefData.volume;
                                metadata.issue = metadata.issue || crossrefData.issue;
                                metadata.pages = metadata.pages || crossrefData.pages;
                            } catch (crossrefError) {
                                console.warn('CrossRef lookup failed:', crossrefError);
                            }
                        }
                        
                        return metadata;
                        
                    } catch (error) {
                        console.error('PubMed fetch error:', error);
                        throw error;
                    }
                },

                async fetchCrossRef(doi) {
                    await utils.respectRateLimit();
                    
                    try {
                        const cleanDoi = doi.replace(/^(https?:\/\/)?(dx\.)?doi\.org\//, '').trim();
                        const url = `https://api.crossref.org/works/${encodeURIComponent(cleanDoi)}`;
                        
                        const headers = { 'Accept': 'application/json' };
                        if (state.settings.crossrefEmail) {
                            headers['User-Agent'] = `SilentStacks/1.0 (mailto:${state.settings.crossrefEmail})`;
                        }
                        
                        const response = await fetch(url, { headers });
                        
                        if (!response.ok) {
                            throw new Error(`DOI not found: ${cleanDoi}`);
                        }
                        
                        const data = await response.json();
                        const work = data.message;
                        
                        const metadata = {
                            doi: cleanDoi,
                            title: (work.title && work.title[0]) || '',
                            authors: this.formatCrossRefAuthors(work.author || []),
                            journal: (work['container-title'] && work['container-title'][0]) || '',
                            year: this.extractCrossRefYear(work.published),
                            volume: work.volume || '',
                            issue: work.issue || '',
                            pages: work.page || '',
                            type: work.type || '',
                            publisher: work.publisher || '',
                            source: 'crossref'
                        };
                        
                        // Try to find PMID from CrossRef data
                        if (work.URL && work.URL.includes('pubmed')) {
                            const pmidMatch = work.URL.match(/(\d{6,8})/);
                            if (pmidMatch) {
                                metadata.pmid = pmidMatch[1];
                                // Cross-populate with PubMed data
                                try {
                                    const pubmedData = await this.fetchPubMed(metadata.pmid);
                                    metadata.meshTerms = pubmedData.meshTerms;
                                    metadata.abstract = pubmedData.abstract;
                                    metadata.nctIds = pubmedData.nctIds;
                                    metadata.isClinicalTrial = pubmedData.isClinicalTrial;
                                } catch (pubmedError) {
                                    console.warn('PubMed cross-population failed:', pubmedError);
                                }
                            }
                        }
                        
                        return metadata;
                        
                    } catch (error) {
                        console.error('CrossRef fetch error:', error);
                        throw error;
                    }
                },

                async fetchClinicalTrial(nctId) {
                    await utils.respectRateLimit();
                    
                    try {
                        // Validate NCT ID format
                        const cleanNct = nctId.toUpperCase().replace(/[^A-Z0-9]/g, '');
                        if (!/^NCT\d{8}$/.test(cleanNct)) {
                            throw new Error('Invalid NCT ID format. Expected format: NCT12345678');
                        }
                        
                        // Use ClinicalTrials.gov API v2
                        const url = `https://clinicaltrials.gov/api/v2/studies/${cleanNct}`;
                        const response = await fetch(url);
                        
                        if (!response.ok) {
                            throw new Error(`Clinical trial not found: ${cleanNct}`);
                        }
                        
                        const data = await response.json();
                        const study = data.studies && data.studies[0];
                        
                        if (!study) {
                            throw new Error(`No study data found for ${cleanNct}`);
                        }
                        
                        const protocol = study.protocolSection || {};
                        const identification = protocol.identificationModule || {};
                        const status = protocol.statusModule || {};
                        const design = protocol.designModule || {};
                        const conditions = protocol.conditionsModule || {};
                        const interventions = protocol.armsInterventionsModule || {};
                        
                        const metadata = {
                            nctId: cleanNct,
                            title: identification.briefTitle || identification.officialTitle || '',
                            officialTitle: identification.officialTitle || '',
                            status: status.overallStatus || '',
                            phase: (design.phases || []).join(', ') || '',
                            studyType: design.studyType || '',
                            enrollment: design.enrollmentInfo?.count || '',
                            conditions: conditions.conditions || [],
                            interventions: (interventions.interventions || []).map(i => i.name || ''),
                            sponsor: protocol.sponsorCollaboratorsModule?.leadSponsor?.name || '',
                            startDate: status.startDateStruct?.date || '',
                            completionDate: status.completionDateStruct?.date || '',
                            keywords: [],
                            source: 'clinicaltrials'
                        };
                        
                        // Create keywords from conditions and interventions
                        metadata.keywords = [
                            ...metadata.conditions,
                            ...metadata.interventions
                        ].map(keyword => ({
                            term: keyword,
                            source: 'nct'
                        }));
                        
                        // Try to find related publications
                        // This would require additional API calls to find linked PMIDs/DOIs
                        
                        return metadata;
                        
                    } catch (error) {
                        console.error('Clinical trial fetch error:', error);
                        throw error;
                    }
                },

                // Helper methods for formatting
                cleanTitle(title) {
                    return title.replace(/\.$/, '').trim();
                },

                formatAuthors(authors) {
                    if (!Array.isArray(authors)) return '';
                    return authors.map(author => author.name || '').join('; ');
                },

                formatCrossRefAuthors(authors) {
                    if (!Array.isArray(authors)) return '';
                    return authors.map(author => {
                        const given = author.given || '';
                        const family = author.family || '';
                        return `${family} ${given}`.trim();
                    }).join(', ');
                },

                formatJournal(record) {
                    return record.fulljournalname || record.source || '';
                },

                extractYear(pubdate) {
                    if (!pubdate) return '';
                    const match = pubdate.match(/\d{4}/);
                    return match ? match[0] : '';
                },

                extractCrossRefYear(published) {
                    if (!published || !published['date-parts'] || !published['date-parts'][0]) return '';
                    return published['date-parts'][0][0].toString();
                },

                detectClinicalTrial(xmlDoc, metadata) {
                    // Check publication types for clinical trial indicators
                    const clinicalTrialTypes = [
                        'Clinical Trial',
                        'Randomized Controlled Trial',
                        'Clinical Trial, Phase I',
                        'Clinical Trial, Phase II',
                        'Clinical Trial, Phase III',
                        'Clinical Trial, Phase IV',
                        'Multicenter Study'
                    ];
                    
                    if (metadata.publicationTypes) {
                        const hasTrialType = metadata.publicationTypes.some(type => 
                            clinicalTrialTypes.includes(type)
                        );
                        if (hasTrialType) return true;
                    }
                    
                    // Check for NCT numbers in abstract or title
                    const fullText = `${metadata.title} ${metadata.abstract}`.toLowerCase();
                    return /nct\d{8}/.test(fullText);
                }
            };

            // Data management with enhanced schema
            const dataManager = {
                save() {
                    try {
                        localStorage.setItem('silentstacks_enhanced_requests', JSON.stringify(state.requests));
                        localStorage.setItem('silentstacks_enhanced_settings', JSON.stringify(state.settings));
                        localStorage.setItem('silentstacks_enhanced_ui', JSON.stringify(state.ui));
                    } catch (error) {
                        console.error('Save failed:', error);
                    }
                },

                load() {
                    try {
                        const savedRequests = localStorage.getItem('silentstacks_enhanced_requests');
                        const savedSettings = localStorage.getItem('silentstacks_enhanced_settings');
                        const savedUI = localStorage.getItem('silentstacks_enhanced_ui');
                        
                        if (savedRequests) {
                            state.requests = JSON.parse(savedRequests);
                        }
                        
                        if (savedSettings) {
                            state.settings = { ...state.settings, ...JSON.parse(savedSettings) };
                        }
                        
                        if (savedUI) {
                            state.ui = { ...state.ui, ...JSON.parse(savedUI) };
                        }
                    } catch (error) {
                        console.error('Load failed:', error);
                    }
                },

                addRequest(requestData) {
                    const now = new Date().toISOString();
                    const followUpAt = utils.calculateFollowUpDate(now, state.settings.followupDays);
                    
                    const request = {
                        id: utils.generateId(),
                        doclineNumber: requestData.doclineNumber || '',
                        pmid: requestData.pmid || '',
                        doi: requestData.doi || '',
                        nctId: requestData.nctId || '',
                        title: requestData.title || '',
                        authors: requestData.authors || '',
                        journal: requestData.journal || '',
                        year: requestData.year || '',
                        volume: requestData.volume || '',
                        issue: requestData.issue || '',
                        pages: requestData.pages || '',
                        patronEmail: requestData.patronEmail || '',
                        priority: requestData.priority || 'normal',
                        status: requestData.status || 'pending',
                        notes: requestData.notes || '',
                        userTags: requestData.userTags || [],
                        meshTerms: requestData.meshTerms || [],
                        nctKeywords: requestData.nctKeywords || [],
                        nctInfo: requestData.nctInfo || null,
                        isClinicalTrial: requestData.isClinicalTrial || false,
                        nlmCitation: '',
                        createdAt: now,
                        updatedAt: now,
                        followUpAt: followUpAt.toISOString(),
                        source: requestData.source || 'manual'
                    };
                    
                    // Generate NLM citation
                    request.nlmCitation = utils.formatNLMCitation(request);
                    
                    state.requests.unshift(request);
                    this.save();
                    return request;
                },

                updateRequest(id, updates) {
                    const index = state.requests.findIndex(r => r.id === id);
                    if (index !== -1) {
                        state.requests[index] = {
                            ...state.requests[index],
                            ...updates,
                            updatedAt: new Date().toISOString()
                        };
                        
                        // Regenerate NLM citation if bibliographic data changed
                        if (updates.title || updates.authors || updates.journal || updates.year) {
                            state.requests[index].nlmCitation = utils.formatNLMCitation(state.requests[index]);
                        }
                        
                        this.save();
                        return state.requests[index];
                    }
                    return null;
                },

                deleteRequest(id) {
                    const index = state.requests.findIndex(r => r.id === id);
                    if (index !== -1) {
                        state.requests.splice(index, 1);
                        this.save();
                        return true;
                    }
                    return false;
                },

                getFilteredRequests() {
                    let filtered = [...state.requests];
                    
                    // Apply tag filters
                    if (state.ui.selectedTags.size > 0) {
                        filtered = filtered.filter(request => {
                            const allTags = [
                                ...(request.meshTerms || []).map(m => m.term),
                                ...(request.nctKeywords || []).map(k => k.term),
                                ...(request.userTags || [])
                            ];
                            
                            return Array.from(state.ui.selectedTags).some(selectedTag =>
                                allTags.some(tag => tag.toLowerCase().includes(selectedTag.toLowerCase()))
                            );
                        });
                    }
                    
                    return filtered;
                }
            };

            // UI Controller with enhanced features
            const uiController = {
                init() {
                    this.bindEvents();
                    this.updateTheme();
                    this.render();
                    this.updateConnectionStatus();
                },

                bindEvents() {
                    // Navigation
                    document.querySelectorAll('.nav-tab').forEach(tab => {
                        tab.addEventListener('click', (e) => {
                            this.switchSection(tab.dataset.section);
                        });
                    });

                    // Form submission
                    document.getElementById('request-form').addEventListener('submit', (e) => {
                        e.preventDefault();
                        this.handleFormSubmit();
                    });

                    // Lookup buttons
                    document.getElementById('lookup-pmid').addEventListener('click', () => {
                        this.handleLookup('pmid');
                    });

                    document.getElementById('lookup-doi').addEventListener('click', () => {
                        this.handleLookup('doi');
                    });

                    document.getElementById('lookup-nct').addEventListener('click', () => {
                        this.handleLookup('nct');
                    });

                    // Bulk processing
                    document.getElementById('process-bulk').addEventListener('click', () => {
                        this.handleBulkProcessing();
                    });

                    document.getElementById('clear-bulk').addEventListener('click', () => {
                        document.getElementById('bulk-identifiers').value = '';
                        document.getElementById('bulk-file').value = '';
                        this.hideBulkProgress();
                        document.getElementById('bulk-results').innerHTML = '';
                    });

                    document.getElementById('cancel-bulk').addEventListener('click', () => {
                        state.processing.canCancel = true;
                    });

                    // File input for bulk processing
                    document.getElementById('bulk-file').addEventListener('change', (e) => {
                        this.handleBulkFile(e);
                    });

                    // Settings
                    document.getElementById('settings-form').addEventListener('submit', (e) => {
                        e.preventDefault();
                        this.handleSettingsSubmit();
                    });

                    // Clear form
                    document.getElementById('clear-form').addEventListener('click', () => {
                        document.getElementById('request-form').reset();
                        document.getElementById('tags-display').style.display = 'none';
                        this.showStatus('Form cleared', 'success');
                    });

                    // Search and filters
                    document.getElementById('search-requests').addEventListener('input', (e) => {
                        this.handleSearch();
                    });

                    ['filter-status', 'filter-priority', 'filter-followup'].forEach(id => {
                        document.getElementById(id).addEventListener('change', () => {
                            this.handleSearch();
                        });
                    });

                    document.getElementById('clear-filters').addEventListener('click', () => {
                        document.getElementById('search-requests').value = '';
                        document.getElementById('filter-status').value = '';
                        document.getElementById('filter-priority').value = '';
                        document.getElementById('filter-followup').value = '';
                        state.ui.selectedTags.clear();
                        this.handleSearch();
                    });

                    // Table sorting
                    document.querySelectorAll('[data-sort]').forEach(th => {
                        th.addEventListener('click', () => {
                            this.handleSort(th.dataset.sort);
                        });
                    });

                    // View toggle
                    document.getElementById('toggle-view').addEventListener('click', () => {
                        this.toggleView();
                    });

                    // Export buttons
                    document.getElementById('export-csv').addEventListener('click', () => {
                        this.exportData('csv');
                    });

                    document.getElementById('export-json').addEventListener('click', () => {
                        this.exportData('json');
                    });

                    document.getElementById('export-nlm').addEventListener('click', () => {
                        this.exportData('nlm');
                    });

                    // Import
                    document.getElementById('import-file').addEventListener('change', (e) => {
                        this.handleImport(e);
                    });

                    // Connection monitoring
                    window.addEventListener('online', () => {
                        state.ui.isOnline = true;
                        this.updateConnectionStatus();
                    });

                    window.addEventListener('offline', () => {
                        state.ui.isOnline = false;
                        this.updateConnectionStatus();
                    });
                },

                switchSection(sectionId) {
                    document.querySelectorAll('.nav-tab').forEach(tab => {
                        tab.classList.toggle('active', tab.dataset.section === sectionId);
                    });
                    
                    document.querySelectorAll('.section').forEach(section => {
                        section.classList.toggle('active', section.id === sectionId);
                    });
                    
                    state.ui.currentSection = sectionId;
                    
                    if (sectionId === 'dashboard') {
                        this.renderDashboard();
                    } else if (sectionId === 'all-requests') {
                        this.renderAllRequests();
                    }
                },

                async handleLookup(type) {
                    const inputId = type === 'nct' ? 'nct-id' : type;
                    const input = document.getElementById(inputId);
                    const button = document.getElementById(`lookup-${type}`);
                    
                    if (!input || !input.value.trim()) {
                        this.showStatus(`Please enter a ${type.toUpperCase()}`, 'error');
                        return;
                    }
                    
                    const identifier = input.value.trim();
                    const originalText = button.textContent;
                    
                    button.disabled = true;
                    button.innerHTML = '<span class="spinner"></span> Looking up...';
                    this.showStatus('Fetching metadata and cross-populating...', 'loading');
                    
                    try {
                        let result;
                        
                        if (type === 'pmid') {
                            result = await apiService.fetchPubMed(identifier);
                        } else if (type === 'doi') {
                            result = await apiService.fetchCrossRef(identifier);
                        } else if (type === 'nct') {
                            result = await apiService.fetchClinicalTrial(identifier);
                        }
                        
                        this.populateForm(result);
                        this.displayAutoTags(result);
                        this.showStatus('✅ Metadata retrieved and cross-populated successfully!', 'success');
                        
                    } catch (error) {
                        console.error('Lookup failed:', error);
                        this.showStatus(`❌ Lookup failed: ${error.message}`, 'error');
                    } finally {
                        button.disabled = false;
                        button.textContent = originalText;
                    }
                },

                populateForm(data) {
                    const fieldMappings = {
                        'pmid': 'pmid',
                        'doi': 'doi',
                        'nct-id': 'nctId',
                        'title': 'title',
                        'authors': 'authors',
                        'journal': 'journal',
                        'year': 'year',
                        'volume': 'volume',
                        'pages': 'pages'
                    };
                    
                    Object.entries(fieldMappings).forEach(([fieldId, dataKey]) => {
                        const element = document.getElementById(fieldId);
                        if (element && data[dataKey]) {
                            element.value = data[dataKey];
                            element.classList.add('auto-filled');
                            
                            // Remove auto-filled class after delay
                            setTimeout(() => {
                                element.classList.remove('auto-filled');
                            }, 3000);
                        }
                    });
                    
                    // Store enhanced data for form submission
                    const form = document.getElementById('request-form');
                    form.dataset.enhancedData = JSON.stringify(data);
                },

                displayAutoTags(data) {
                    const tagsDisplay = document.getElementById('tags-display');
                    const meshContainer = document.getElementById('mesh-tags');
                    const nctContainer = document.getElementById('nct-tags');
                    
                    meshContainer.innerHTML = '';
                    nctContainer.innerHTML = '';
                    
                    let hasAnyTags = false;
                    
                    // Display MeSH terms
                    if (data.meshTerms && data.meshTerms.length > 0) {
                        hasAnyTags = true;
                        const meshTitle = document.createElement('h5');
                        meshTitle.textContent = '🏷️ MeSH Terms';
                        meshTitle.style.marginBottom = '8px';
                        meshContainer.appendChild(meshTitle);
                        
                        data.meshTerms.forEach(mesh => {
                            const tag = document.createElement('span');
                            tag.className = 'tag mesh';
                            tag.textContent = mesh.term + (mesh.majorTopic ? ' ⭐' : '');
                            tag.title = `Click to add as user tag (${mesh.majorTopic ? 'Major' : 'Minor'} topic)`;
                            tag.addEventListener('click', () => this.addUserTag(mesh.term));
                            meshContainer.appendChild(tag);
                        });
                    }
                    
                    // Display NCT keywords
                    if (data.keywords && data.keywords.length > 0) {
                        hasAnyTags = true;
                        const nctTitle = document.createElement('h5');
                        nctTitle.textContent = '🧪 Clinical Trial Keywords';
                        nctTitle.style.marginBottom = '8px';
                        nctContainer.appendChild(nctTitle);
                        
                        data.keywords.forEach(keyword => {
                            const tag = document.createElement('span');
                            tag.className = 'tag nct';
                            tag.textContent = keyword.term || keyword;
                            tag.title = 'Click to add as user tag';
                            tag.addEventListener('click', () => this.addUserTag(keyword.term || keyword));
                            nctContainer.appendChild(tag);
                        });
                    }
                    
                    tagsDisplay.style.display = hasAnyTags ? 'block' : 'none';
                },

                addUserTag(tagText) {
                    const userTagsInput = document.getElementById('user-tags');
                    const currentTags = userTagsInput.value.split(',').map(t => t.trim()).filter(Boolean);
                    
                    if (!currentTags.includes(tagText)) {
                        currentTags.push(tagText);
                        userTagsInput.value = currentTags.join(', ');
                        
                        // Visual feedback
                        this.showStatus(`Added tag: ${tagText}`, 'success');
                    }
                },

                async handleBulkProcessing() {
                    const textArea = document.getElementById('bulk-identifiers');
                    const fileInput = document.getElementById('bulk-file');
                    
                    let inputText = textArea.value.trim();
                    
                    // If no text but file selected, read file
                    if (!inputText && fileInput.files[0]) {
                        const file = fileInput.files[0];
                        inputText = await this.readFileAsText(file);
                    }
                    
                    if (!inputText) {
                        this.showBulkStatus('Please enter identifiers or select a file', 'error');
                        return;
                    }
                    
                    const identifiers = utils.normalizeIdentifiers(inputText);
                    
                    if (identifiers.length === 0) {
                        this.showBulkStatus('No valid identifiers found in the input', 'error');
                        return;
                    }
                    
                    if (identifiers.length > 100) {
                        this.showBulkStatus('Too many identifiers. Maximum 100 allowed per batch.', 'error');
                        return;
                    }
                    
                    await this.processBulkIdentifiers(identifiers);
                },

                async processBulkIdentifiers(identifiers) {
                    state.processing.isActive = true;
                    state.processing.canCancel = false;
                    
                    this.showBulkProgress();
                    document.getElementById('cancel-bulk').style.display = 'inline-flex';
                    document.getElementById('process-bulk').disabled = true;
                    
                    const progressFill = document.getElementById('progress-fill');
                    const progressText = document.getElementById('progress-text');
                    
                    const results = [];
                    const errors = [];
                    
                    for (let i = 0; i < identifiers.length; i++) {
                        if (state.processing.canCancel) {
                            this.showBulkStatus('❌ Processing cancelled by user', 'error');
                            break;
                        }
                        
                        const identifier = identifiers[i];
                        const progress = ((i + 1) / identifiers.length) * 100;
                        
                        progressFill.style.width = `${progress}%`;
                        progressText.textContent = `Processing ${identifier.type.toUpperCase()} ${identifier.value} (${i + 1} of ${identifiers.length})...`;
                        
                        try {
                            let metadata;
                            
                            if (identifier.type === 'pmid') {
                                metadata = await apiService.fetchPubMed(identifier.value);
                            } else if (identifier.type === 'doi') {
                                metadata = await apiService.fetchCrossRef(identifier.value);
                            } else if (identifier.type === 'nct') {
                                metadata = await apiService.fetchClinicalTrial(identifier.value);
                            }
                            
                            // Create request from metadata
                            const request = dataManager.addRequest({
                                ...metadata,
                                priority: 'normal',
                                status: 'pending'
                            });
                            
                            results.push({ 
                                identifier: identifier.value, 
                                type: identifier.type,
                                request, 
                                status: 'success',
                                title: metadata.title || 'N/A'
                            });
                            
                        } catch (error) {
                            console.error(`Failed to process ${identifier.type} ${identifier.value}:`, error);
                            
                            // Still create a minimal request with error info
                            const errorRequest = dataManager.addRequest({
                                [identifier.type]: identifier.value,
                                title: `Error: ${error.message}`,
                                status: 'pending',
                                priority: 'normal',
                                notes: `Failed to fetch metadata: ${error.message}`
                            });
                            
                            errors.push({ 
                                identifier: identifier.value, 
                                type: identifier.type,
                                error: error.message,
                                request: errorRequest
                            });
                        }
                        
                        // Rate limiting delay
                        if (i < identifiers.length - 1) {
                            await utils.delay(API_DELAY);
                        }
                    }
                    
                    this.showBulkResults(results, errors);
                    this.hideBulkProgress();
                    this.render();
                    
                    state.processing.isActive = false;
                    document.getElementById('cancel-bulk').style.display = 'none';
                    document.getElementById('process-bulk').disabled = false;
                },

                showBulkProgress() {
                    const progressContainer = document.getElementById('bulk-progress');
                    progressContainer.style.display = 'block';
                },

                hideBulkProgress() {
                    const progressContainer = document.getElementById('bulk-progress');
                    progressContainer.style.display = 'none';
                },

                showBulkResults(results, errors) {
                    const resultsContainer = document.getElementById('bulk-results');
                    
                    let html = `
                        <div style="margin-bottom: 15px;">
                            <strong>Bulk Processing Complete</strong><br>
                            ✅ Successfully processed: ${results.length}<br>
                            ❌ Errors: ${errors.length}
                        </div>
                    `;
                    
                    if (results.length > 0) {
                        html += `
                            <div style="margin-bottom: 15px;">
                                <h4>✅ Successfully Added:</h4>
                                <ul style="max-height: 200px; overflow-y: auto;">
                                    ${results.map(r => 
                                        `<li><strong>${r.type.toUpperCase()} ${r.identifier}:</strong> ${utils.sanitize(r.title)}</li>`
                                    ).join('')}
                                </ul>
                            </div>
                        `;
                    }
                    
                    if (errors.length > 0) {
                        html += `
                            <div>
                                <h4>❌ Errors (Still Added with Error Notes):</h4>
                                <ul style="max-height: 200px; overflow-y: auto;">
                                    ${errors.map(e => 
                                        `<li><strong>${e.type.toUpperCase()} ${e.identifier}:</strong> ${utils.sanitize(e.error)}</li>`
                                    ).join('')}
                                </ul>
                            </div>
                        `;
                    }
                    
                    resultsContainer.innerHTML = html;
                    this.showBulkStatus(`✅ Processed ${results.length + errors.length} identifiers!`, 'success');
                },

                handleBulkFile(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    
                    this.readFileAsText(file).then(text => {
                        document.getElementById('bulk-identifiers').value = text;
                    }).catch(error => {
                        this.showBulkStatus(`File read error: ${error.message}`, 'error');
                    });
                },

                readFileAsText(file) {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = e => resolve(e.target.result);
                        reader.onerror = e => reject(new Error('Failed to read file'));
                        reader.readAsText(file);
                    });
                },

                handleFormSubmit() {
                    const formData = new FormData(document.getElementById('request-form'));
                    const data = Object.fromEntries(formData.entries());
                    
                    if (!data.title) {
                        this.showStatus('Title is required', 'error');
                        return;
                    }
                    
                    // Check for enhanced data from lookups
                    const form = document.getElementById('request-form');
                    if (form.dataset.enhancedData) {
                        const enhancedData = JSON.parse(form.dataset.enhancedData);
                        Object.assign(data, enhancedData);
                    }
                    
                    // Process user tags
                    if (data.userTags) {
                        data.userTags = data.userTags.split(',').map(tag => tag.trim()).filter(Boolean);
                    }
                    
                    dataManager.addRequest(data);
                    document.getElementById('request-form').reset();
                    form.removeAttribute('data-enhanced-data');
                    document.getElementById('tags-display').style.display = 'none';
                    
                    this.showStatus('✅ Request created successfully!', 'success');
                    this.render();
                },

                handleSearch() {
                    const query = document.getElementById('search-requests').value.toLowerCase();
                    const statusFilter = document.getElementById('filter-status').value;
                    const priorityFilter = document.getElementById('filter-priority').value;
                    const followupFilter = document.getElementById('filter-followup').value;
                    
                    let filtered = state.requests;
                    
                    // Text search across all fields
                    if (query) {
                        filtered = filtered.filter(request => {
                            const searchText = [
                                request.title,
                                request.authors,
                                request.journal,
                                request.pmid,
                                request.doi,
                                request.nctId,
                                request.doclineNumber,
                                request.patronEmail,
                                request.notes,
                                request.nlmCitation,
                                ...(request.userTags || []),
                                ...(request.meshTerms || []).map(m => m.term),
                                ...(request.nctKeywords || []).map(k => k.term)
                            ].join(' ').toLowerCase();
                            
                            return searchText.includes(query);
                        });
                    }
                    
                    // Status filter
                    if (statusFilter) {
                        filtered = filtered.filter(r => r.status === statusFilter);
                    }
                    
                    // Priority filter
                    if (priorityFilter) {
                        filtered = filtered.filter(r => r.priority === priorityFilter);
                    }
                    
                    // Follow-up filter
                    if (followupFilter) {
                        filtered = filtered.filter(r => {
                            const isDue = utils.isFollowUpDue(r.followUpAt, r.status);
                            return followupFilter === 'due' ? isDue : !isDue;
                        });
                    }
                    
                    // Tag filter
                    if (state.ui.selectedTags.size > 0) {
                        filtered = filtered.filter(request => {
                            const allTags = [
                                ...(request.meshTerms || []).map(m => m.term),
                                ...(request.nctKeywords || []).map(k => k.term),
                                ...(request.userTags || [])
                            ];
                            
                            return Array.from(state.ui.selectedTags).some(selectedTag =>
                                allTags.some(tag => tag.toLowerCase().includes(selectedTag.toLowerCase()))
                            );
                        });
                    }
                    
                    this.renderFilteredRequests(filtered);
                },

                handleSort(field) {
                    if (state.ui.sortField === field) {
                        state.ui.sortDirection = state.ui.sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        state.ui.sortField = field;
                        state.ui.sortDirection = 'asc';
                    }
                    
                    // Update sort indicators
                    document.querySelectorAll('[data-sort]').forEach(th => {
                        th.classList.remove('sorted-asc', 'sorted-desc');
                        if (th.dataset.sort === field) {
                            th.classList.add(`sorted-${state.ui.sortDirection}`);
                        }
                    });
                    
                    this.handleSearch();
                    dataManager.save();
                },

                toggleView() {
                    state.ui.viewMode = state.ui.viewMode === 'table' ? 'cards' : 'table';
                    
                    const table = document.querySelector('.data-table').parentElement;
                    const cards = document.getElementById('request-cards');
                    const toggleBtn = document.getElementById('toggle-view');
                    
                    if (state.ui.viewMode === 'table') {
                        table.style.display = 'block';
                        cards.style.display = 'none';
                        toggleBtn.textContent = '🔄 Switch to Card View';
                    } else {
                        table.style.display = 'none';
                        cards.style.display = 'block';
                        toggleBtn.textContent = '🔄 Switch to Table View';
                    }
                    
                    this.handleSearch();
                    dataManager.save();
                },

                handleSettingsSubmit() {
                    const form = document.getElementById('settings-form');
                    const formData = new FormData(form);
                    
                    state.settings = {
                        followupDays: parseInt(formData.get('followup-days')) || 5,
                        theme: formData.get('theme') || 'light',
                        apiKey: formData.get('api-key') || '',
                        crossrefEmail: formData.get('crossref-email') || ''
                    };
                    
                    this.updateTheme();
                    dataManager.save();
                    this.showStatus('⚙️ Settings saved successfully!', 'success');
                },

                updateTheme() {
                    document.documentElement.setAttribute('data-theme', state.settings.theme);
                },

                updateConnectionStatus() {
                    const statusEl = document.getElementById('connection-status');
                    if (state.ui.isOnline) {
                        statusEl.textContent = '🌐 Online';
                        statusEl.style.color = 'var(--success-color)';
                    } else {
                        statusEl.textContent = '📡 Offline';
                        statusEl.style.color = 'var(--danger-color)';
                    }
                },

                showStatus(message, type = 'info') {
                    const statusEl = document.getElementById('lookup-status');
                    if (statusEl) {
                        statusEl.textContent = message;
                        statusEl.className = `status-message ${type}`;
                        
                        if (type === 'success' || type === 'error') {
                            setTimeout(() => {
                                statusEl.style.display = 'none';
                            }, 5000);
                        }
                    }
                },

                showBulkStatus(message, type = 'info') {
                    const statusEl = document.getElementById('bulk-status');
                    if (statusEl) {
                        statusEl.textContent = message;
                        statusEl.className = `status-message ${type}`;
                    }
                },

                render() {
                    this.renderDashboard();
                    this.renderAllRequests();
                    this.updateSelectedTagsDisplay();
                },

                renderDashboard() {
                    const stats = this.calculateStats();
                    
                    document.getElementById('total-requests').textContent = stats.total;
                    document.getElementById('clinical-trials').textContent = stats.clinicalTrials;
                    document.getElementById('followups-due').textContent = stats.followupsDue;
                    document.getElementById('fulfilled-requests').textContent = stats.fulfilled;
                    
                    // Render recent requests
                    const recentContainer = document.getElementById('recent-requests');
                    const recentRequests = state.requests.slice(0, 5);
                    
                    if (recentRequests.length === 0) {
                        recentContainer.innerHTML = '<p style="color: var(--text-muted); text-align: center; padding: 20px;">No requests yet. Create your first request!</p>';
                    } else {
                        recentContainer.innerHTML = recentRequests.map(request => this.createRequestCard(request)).join('');
                    }
                },

                calculateStats() {
                    const total = state.requests.length;
                    const clinicalTrials = state.requests.filter(r => r.isClinicalTrial || r.nctId).length;
                    const fulfilled = state.requests.filter(r => r.status === 'fulfilled').length;
                    const followupsDue = state.requests.filter(r => 
                        utils.isFollowUpDue(r.followUpAt, r.status)
                    ).length;
                    
                    return { total, clinicalTrials, fulfilled, followupsDue };
                },

                renderAllRequests() {
                    this.handleSearch(); // This will render filtered results
                },

                renderFilteredRequests(requests) {
                    // Sort requests
                    const sorted = this.sortRequests(requests);
                    
                    if (state.ui.viewMode === 'table') {
                        this.renderTable(sorted);
                    } else {
                        this.renderCards(sorted);
                    }
                },

                sortRequests(requests) {
                    return [...requests].sort((a, b) => {
                        let aVal = a[state.ui.sortField] || '';
                        let bVal = b[state.ui.sortField] || '';
                        
                        // Special handling for dates
                        if (state.ui.sortField === 'followUpAt' || state.ui.sortField === 'createdAt') {
                            aVal = new Date(aVal).getTime();
                            bVal = new Date(bVal).getTime();
                        }
                        
                        // Special handling for priority
                        if (state.ui.sortField === 'priority') {
                            const priorityOrder = { 'urgent': 3, 'rush': 2, 'normal': 1 };
                            aVal = priorityOrder[aVal] || 0;
                            bVal = priorityOrder[bVal] || 0;
                        }
                        
                        if (state.ui.sortDirection === 'asc') {
                            return aVal > bVal ? 1 : -1;
                        } else {
                            return aVal < bVal ? 1 : -1;
                        }
                    });
                },

                renderTable(requests) {
                    const tbody = document.getElementById('requests-table-body');
                    
                    if (requests.length === 0) {
                        tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; color: var(--text-muted); padding: 20px;">No requests found</td></tr>';
                        return;
                    }
                    
                    tbody.innerHTML = requests.map(request => {
                        const followUpDue = utils.isFollowUpDue(request.followUpAt, request.status);
                        const followUpDate = new Date(request.followUpAt).toLocaleDateString();
                        
                        return `
                            <tr class="${followUpDue ? 'follow-up-due' : ''}">
                                <td>${utils.safeValue(request.doclineNumber)}</td>
                                <td>${utils.safeValue(request.pmid)}</td>
                                <td class="nlm-citation">${utils.safeValue(request.nlmCitation)}</td>
                                <td>${utils.safeValue(request.patronEmail)}</td>
                                <td>
                                    <span class="tag ${request.priority}">${request.priority || 'normal'}</span>
                                </td>
                                <td>
                                    <select onchange="uiController.updateRequestStatus('${request.id}', this.value)" class="request-status-select">
                                        <option value="pending" ${request.status === 'pending' ? 'selected' : ''}>Pending</option>
                                        <option value="in-progress" ${request.status === 'in-progress' ? 'selected' : ''}>In Progress</option>
                                        <option value="fulfilled" ${request.status === 'fulfilled' ? 'selected' : ''}>Fulfilled</option>
                                        <option value="cancelled" ${request.status === 'cancelled' ? 'selected' : ''}>Cancelled</option>
                                    </select>
                                </td>
                                <td>
                                    ${followUpDue ? 
                                        `<span class="follow-up-due">DUE</span>` : 
                                        `<span class="follow-up-ok">${followUpDate}</span>`
                                    }
                                </td>
                                <td>
                                    <button class="btn btn-secondary" onclick="uiController.editRequest('${request.id}')" style="padding: 4px 8px; font-size: 0.8rem;">Edit</button>
                                    <button class="btn btn-danger" onclick="uiController.deleteRequest('${request.id}')" style="padding: 4px 8px; font-size: 0.8rem;">Delete</button>
                                </td>
                            </tr>
                        `;
                    }).join('');
                },

                renderCards(requests) {
                    const container = document.getElementById('request-cards');
                    
                    if (requests.length === 0) {
                        container.innerHTML = '<p style="color: var(--text-muted); text-align: center; padding: 20px;">No requests found</p>';
                        return;
                    }
                    
                    container.innerHTML = requests.map(request => this.createRequestCard(request, true)).join('');
                },

                createRequestCard(request, detailed = false) {
                    const followUpDue = utils.isFollowUpDue(request.followUpAt, request.status);
                    const isClinical = request.isClinicalTrial || request.nctId;
                    
                    // Build NCT info display
                    let nctInfo = '';
                    if (request.nctInfo && detailed) {
                        nctInfo = `
                            <div class="nct-info">
                                <div class="nct-title">🧪 ${request.nctInfo.title || request.nctId}</div>
                                <span class="nct-status ${request.nctInfo.status.toLowerCase().replace(/\s+/g, '-')}">${request.nctInfo.status}</span>
                                ${request.nctInfo.phase ? `<span style="margin-left: 8px; font-size: 0.8rem;">Phase: ${request.nctInfo.phase}</span>` : ''}
                            </div>
                        `;
                    }
                    
                    // Build tags display
                    let tagsDisplay = '';
                    if (detailed) {
                        const allTags = [
                            ...(request.meshTerms || []).map(m => ({ text: m.term, type: 'mesh', major: m.majorTopic })),
                            ...(request.nctKeywords || []).map(k => ({ text: k.term || k, type: 'nct' })),
                            ...(request.userTags || []).map(t => ({ text: t, type: 'user' }))
                        ];
                        
                        if (allTags.length > 0) {
                            tagsDisplay = `
                                <div class="tags-container">
                                    ${allTags.map(tag => 
                                        `<span class="tag ${tag.type} ${tag.major ? 'major' : ''}" 
                                               onclick="uiController.toggleTagFilter('${tag.text}')"
                                               title="Click to filter by this tag">
                                            ${tag.text}${tag.major ? ' ⭐' : ''}
                                        </span>`
                                    ).join('')}
                                </div>
                            `;
                        }
                    }
                    
                    return `
                        <div class="request-card ${isClinical ? 'clinical-trial' : ''} ${followUpDue ? 'follow-up-due' : ''}" data-id="${request.id}">
                            <div class="request-header">
                                <div style="flex: 1;">
                                    <div class="nlm-citation">
                                        ${utils.safeValue(request.nlmCitation)}
                                    </div>
                                    ${nctInfo}
                                    <div style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 8px;">
                                        ${request.doclineNumber ? `DOCLINE: ${request.doclineNumber} • ` : ''}
                                        ${request.patronEmail ? `📧 ${request.patronEmail} • ` : ''}
                                        🕒 ${this.getTimeAgo(request.createdAt)}
                                        ${followUpDue ? ' • <span style="color: var(--warning-color); font-weight: 600;">⚠️ FOLLOW-UP DUE</span>' : ''}
                                    </div>
                                </div>
                                <div>
                                    <select class="request-status-select status-${request.status}" 
                                            onchange="uiController.updateRequestStatus('${request.id}', this.value)">
                                        <option value="pending" ${request.status === 'pending' ? 'selected' : ''}>Pending</option>
                                        <option value="in-progress" ${request.status === 'in-progress' ? 'selected' : ''}>In Progress</option>
                                        <option value="fulfilled" ${request.status === 'fulfilled' ? 'selected' : ''}>Fulfilled</option>
                                        <option value="cancelled" ${request.status === 'cancelled' ? 'selected' : ''}>Cancelled</option>
                                    </select>
                                </div>
                            </div>
                            
                            ${tagsDisplay}
                            
                            ${request.notes ? `
                                <div style="margin: 10px 0; padding: 10px; background: var(--bg-secondary); border-radius: var(--border-radius);">
                                    📝 ${utils.sanitize(request.notes)}
                                </div>
                            ` : ''}
                            
                            ${detailed ? `
                                <div style="display: flex; gap: 10px; margin-top: 15px;">
                                    <button class="btn btn-secondary" onclick="uiController.editRequest('${request.id}')" style="padding: 6px 12px; font-size: 0.9rem;">
                                        ✏️ Edit
                                    </button>
                                    <button class="btn btn-danger" onclick="uiController.deleteRequest('${request.id}')" style="padding: 6px 12px; font-size: 0.9rem;">
                                        🗑️ Delete
                                    </button>
                                </div>
                            ` : ''}
                        </div>
                    `;
                },

                toggleTagFilter(tagText) {
                    if (state.ui.selectedTags.has(tagText)) {
                        state.ui.selectedTags.delete(tagText);
                    } else {
                        state.ui.selectedTags.add(tagText);
                    }
                    
                    this.updateSelectedTagsDisplay();
                    this.handleSearch();
                    dataManager.save();
                },

                updateSelectedTagsDisplay() {
                    const container = document.getElementById('selected-tags');
                    
                    if (state.ui.selectedTags.size === 0) {
                        container.innerHTML = '';
                        return;
                    }
                    
                    container.innerHTML = `
                        <div style="margin-bottom: 8px; font-weight: 600;">Active Tag Filters:</div>
                        ${Array.from(state.ui.selectedTags).map(tag => 
                            `<span class="tag selected" onclick="uiController.toggleTagFilter('${tag}')">
                                ${tag} ✕
                            </span>`
                        ).join('')}
                    `;
                },

                updateRequestStatus(id, newStatus) {
                    dataManager.updateRequest(id, { status: newStatus });
                    this.render();
                },

                editRequest(id) {
                    const request = state.requests.find(r => r.id === id);
                    if (!request) return;
                    
                    this.populateForm(request);
                    this.switchSection('add-request');
                    
                    // Store edit mode
                    document.getElementById('request-form').dataset.editId = id;
                },

                deleteRequest(id) {
                    if (!confirm('Are you sure you want to delete this request?')) return;
                    
                    dataManager.deleteRequest(id);
                    this.render();
                },

                getTimeAgo(date) {
                    const now = CURRENT_DATE;
                    const diffMs = now - new Date(date);
                    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
                    
                    if (diffDays === 0) return 'Today';
                    if (diffDays === 1) return 'Yesterday';
                    if (diffDays < 7) return `${diffDays} days ago`;
                    if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
                    return `${Math.floor(diffDays / 30)} months ago`;
                },

                exportData(format) {
                    try {
                        let content, filename, mimeType;
                        
                        if (format === 'csv') {
                            content = this.convertToCSV(state.requests);
                            filename = `silentstacks-enhanced-${CURRENT_DATE.toISOString().split('T')[0]}.csv`;
                            mimeType = 'text/csv';
                        } else if (format === 'nlm') {
                            content = this.convertToNLM(state.requests);
                            filename = `silentstacks-nlm-citations-${CURRENT_DATE.toISOString().split('T')[0]}.txt`;
                            mimeType = 'text/plain';
                        } else {
                            content = JSON.stringify({
                                version: '1.3-enhanced',
                                exportedAt: new Date().toISOString(),
                                requests: state.requests,
                                settings: state.settings
                            }, null, 2);
                            filename = `silentstacks-enhanced-${CURRENT_DATE.toISOString().split('T')[0]}.json`;
                            mimeType = 'application/json';
                        }
                        
                        this.downloadFile(content, filename, mimeType);
                        this.showStatus(`✅ ${format.toUpperCase()} export completed!`, 'success');
                    } catch (error) {
                        console.error('Export failed:', error);
                        this.showStatus('❌ Export failed', 'error');
                    }
                },

                convertToCSV(requests) {
                    if (requests.length === 0) return '';
                    
                    const headers = [
                        'DOCLINE #', 'PMID', 'DOI', 'NCT ID', 'NLM Citation', 'Title', 'Authors', 'Journal', 'Year',
                        'Volume', 'Issue', 'Pages', 'Patron Email', 'Priority', 'Status', 'Follow-Up Date',
                        'MeSH Terms', 'NCT Keywords', 'User Tags', 'Notes', 'Created', 'Updated'
                    ];
                    
                    const rows = requests.map(r => [
                        utils.safeValue(r.doclineNumber),
                        utils.safeValue(r.pmid),
                        utils.safeValue(r.doi),
                        utils.safeValue(r.nctId),
                        utils.safeValue(r.nlmCitation),
                        utils.safeValue(r.title),
                        utils.safeValue(r.authors),
                        utils.safeValue(r.journal),
                        utils.safeValue(r.year),
                        utils.safeValue(r.volume),
                        utils.safeValue(r.issue),
                        utils.safeValue(r.pages),
                        utils.safeValue(r.patronEmail),
                        utils.safeValue(r.priority),
                        utils.safeValue(r.status),
                        utils.safeValue(new Date(r.followUpAt).toLocaleDateString()),
                        (r.meshTerms || []).map(m => m.term).join('; ') || 'N/A',
                        (r.nctKeywords || []).map(k => k.term || k).join('; ') || 'N/A',
                        (r.userTags || []).join('; ') || 'N/A',
                        utils.safeValue(r.notes),
                        utils.safeValue(new Date(r.createdAt).toLocaleDateString()),
                        utils.safeValue(new Date(r.updatedAt).toLocaleDateString())
                    ]);
                    
                    return [headers, ...rows]
                        .map(row => row.map(cell => `"${(cell + '').replace(/"/g, '""')}"`).join(','))
                        .join('\n');
                },

                convertToNLM(requests) {
                    return requests
                        .map(r => r.nlmCitation || 'N/A')
                        .join('\n\n');
                },

                downloadFile(content, filename, mimeType) {
                    const blob = new Blob([content], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                },

                handleImport(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    
                    this.readFileAsText(file).then(text => {
                        try {
                            let importedData;
                            
                            if (file.name.endsWith('.json')) {
                                const data = JSON.parse(text);
                                importedData = data.requests || data;
                            } else if (file.name.endsWith('.csv')) {
                                importedData = this.parseCSV(text);
                            } else {
                                // Treat as identifier list
                                const identifiers = utils.normalizeIdentifiers(text);
                                document.getElementById('bulk-identifiers').value = text;
                                this.switchSection('bulk-processing');
                                return;
                            }
                            
                            if (Array.isArray(importedData)) {
                                let imported = 0;
                                importedData.forEach(requestData => {
                                    if (requestData.title || requestData.pmid || requestData.doi || requestData.nctId) {
                                        dataManager.addRequest(requestData);
                                        imported++;
                                    }
                                });
                                
                                this.render();
                                document.getElementById('import-status').textContent = `✅ Imported ${imported} requests successfully!`;
                                document.getElementById('import-status').className = 'status-message success';
                            }
                            
                        } catch (error) {
                            console.error('Import failed:', error);
                            document.getElementById('import-status').textContent = `❌ Import failed: ${error.message}`;
                            document.getElementById('import-status').className = 'status-message error';
                        }
                    });
                },

                parseCSV(csvText) {
                    const lines = csvText.split('\n').filter(line => line.trim());
                    if (lines.length < 2) return [];
                    
                    const headers = lines[0].split(',').map(h => h.replace(/"/g, '').trim().toLowerCase());
                    const requests = [];
                    
                    for (let i = 1; i < lines.length; i++) {
                        const values = lines[i].split(',').map(v => v.replace(/"/g, '').trim());
                        const request = {};
                        
                        headers.forEach((header, index) => {
                            if (values[index] && values[index] !== 'N/A') {
                                request[header] = values[index];
                            }
                        });
                        
                        if (request.title || request.pmid || request.doi) {
                            requests.push(request);
                        }
                    }
                    
                    return requests;
                }
            };

            // Make UI controller globally available
            window.uiController = uiController;

            // Initialize application
            function init() {
                console.log('🚀 Initializing SilentStacks Enhanced with Cross-Population...');
                console.log(`📅 Current date: ${CURRENT_DATE.toLocaleDateString()} (Eastern Time)`);
                
                dataManager.load();
                uiController.init();
                
                // Load settings into form
                const settingsForm = document.getElementById('settings-form');
                if (settingsForm) {
                    document.getElementById('followup-days').value = state.settings.followupDays;
                    document.getElementById('theme').value = state.settings.theme;
                    document.getElementById('api-key').value = state.settings.apiKey;
                    document.getElementById('crossref-email').value = state.settings.crossrefEmail;
                }
                
                console.log('✅ SilentStacks Enhanced initialized successfully!');
                console.log(`📊 Loaded ${state.requests.length} requests`);
            }

            // Start when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                init();
            }
        })();
    </script>
</body>
</html>