/*!
 * SilentStacks v2.0 - ILL Management System
 * Enhanced with security features and data validation
 * (c) 2025 - Optimized for thumbdrive deployment
 */

// Enhanced Error Boundary System
const ErrorBoundary = {
    withErrorBoundary: (operation, fallback, context) => {
        try {
            return operation();
        } catch (error) {
            ErrorBoundary.logError(error, context);
            announceToScreenReader(`Operation failed: ${context}`);
            return fallback ? fallback() : null;
        }
    },
    
    logError: (error, context) => {
        const logEntry = {
            timestamp: new Date().toISOString(),
            context: context || 'Unknown',
            message: error.message,
            stack: error.stack?.substring(0, 200), // Truncate for storage
            userAgent: navigator.userAgent.substring(0, 100)
        };
        
        console.error('SilentStacks Error:', logEntry);
        
        // Store in localStorage for debugging (non-PII only)
        try {
            const errorLog = SafeStorage.getItem('silentStacks_errorLog', []);
            errorLog.push(logEntry);
            
            // Keep only last 50 errors
            if (errorLog.length > 50) {
                errorLog.splice(0, errorLog.length - 50);
            }
            
            SafeStorage.setItem('silentStacks_errorLog', errorLog);
        } catch (storageError) {
            console.warn('Could not log error to storage:', storageError);
        }
    }
};

// Performance Monitor
const PerformanceMonitor = {
    timers: new Map(),
    
    startTimer: (name) => {
        PerformanceMonitor.timers.set(name, performance.now());
    },
    
    endTimer: (name) => {
        const startTime = PerformanceMonitor.timers.get(name);
        if (startTime) {
            const duration = performance.now() - startTime;
            PerformanceMonitor.timers.delete(name);
            PerformanceMonitor.recordMetric(name, duration);
            return duration;
        }
        return null;
    },
    
    recordMetric: (operation, duration) => {
        const metric = {
            operation,
            duration: Math.round(duration),
            timestamp: Date.now()
        };
        
        try {
            const metrics = SafeStorage.getItem('silentStacks_metrics', []);
            metrics.push(metric);
            
            // Keep only last 100 metrics
            if (metrics.length > 100) {
                metrics.splice(0, metrics.length - 100);
            }
            
            SafeStorage.setItem('silentStacks_metrics', metrics);
        } catch (error) {
            console.warn('Could not record performance metric:', error);
        }
    }
};

// Security & Validation Utilities
const SecurityUtils = {
    // Input sanitization
    sanitizeHtml: (str) => {
        if (!str) return '';
        const map = {'&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#x27;', '/': '&#x2F;'};
        return str.replace(/[&<>"'/]/g, (s) => map[s]);
    },
    
    // XSS prevention
    escapeScript: (str) => {
        if (!str) return '';
        return str.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
    },
    
    // Email validation
    isValidEmail: (email) => {
        const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return re.test(email) && email.length <= 254;
    },
    
    // PMID validation
    isValidPMID: (pmid) => {
        return /^\d{6,9}$/.test(String(pmid).trim());
    },
    
    // DOI validation
    isValidDOI: (doi) => {
        return /^10\.[^\s"']+$/.test(String(doi).trim());
    },
    
    // NCT validation
    isValidNCT: (nct) => {
        return /^NCT\d{8}$/i.test(String(nct).trim());
    },
    
    // File upload validation
    isValidFileType: (fileName) => {
        const allowedTypes = ['.csv', '.json', '.txt'];
        const ext = fileName.toLowerCase().substring(fileName.lastIndexOf('.'));
        return allowedTypes.includes(ext);
    },
    
    // Size limit check
    isValidFileSize: (file, maxSizeMB = 10) => {
        return file.size <= maxSizeMB * 1024 * 1024;
    },
    
    // Clean data for storage
    cleanForStorage: (data) => {
        if (typeof data === 'string') {
            return SecurityUtils.sanitizeHtml(SecurityUtils.escapeScript(data));
        }
        if (Array.isArray(data)) {
            return data.map(item => SecurityUtils.cleanForStorage(item));
        }
        if (data && typeof data === 'object') {
            const cleaned = {};
            for (let key in data) {
                if (data.hasOwnProperty(key)) {
                    cleaned[key] = SecurityUtils.cleanForStorage(data[key]);
                }
            }
            return cleaned;
        }
        return data;
    }
};

// Rate Limiting for API calls
class RateLimit {
    constructor(maxRequests = 10, timeWindow = 60000) {
        this.requests = [];
        this.maxRequests = maxRequests;
        this.timeWindow = timeWindow;
    }
    
    canMakeRequest() {
        const now = Date.now();
        this.requests = this.requests.filter(time => now - time < this.timeWindow);
        
        if (this.requests.length >= this.maxRequests) {
            return false;
        }
        
        this.requests.push(now);
        return true;
    }
}

// Enhanced LocalStorage with error handling
const SafeStorage = {
    setItem: (key, data) => {
        try {
            const cleanData = SecurityUtils.cleanForStorage(data);
            localStorage.setItem(key, JSON.stringify(cleanData));
            return true;
        } catch (e) {
            if (e.name === 'QuotaExceededError') {
                console.warn('Storage quota exceeded, attempting cleanup');
                SafeStorage.cleanup();
                try {
                    localStorage.setItem(key, JSON.stringify(data));
                    return true;
                } catch (e2) {
                    console.error('Storage failed after cleanup:', e2);
                    return false;
                }
            }
            console.error('Storage error:', e);
            return false;
        }
    },
    
    getItem: (key, fallback = null) => {
        try {
            const item = localStorage.getItem(key);
            return item ? JSON.parse(item) : fallback;
        } catch (e) {
            console.error('Error reading from storage:', e);
            return fallback;
        }
    },
    
    cleanup: () => {
        try {
            const requests = SafeStorage.getItem('silentStacks_requests', []);
            if (requests.length > 1000) {
                const recent = requests.slice(0, 500);
                SafeStorage.setItem('silentStacks_requests', recent);
            }
        } catch (e) {
            console.error('Cleanup failed:', e);
        }
    }
};

// Main Application State
const APP_STATE = {
    requests: SafeStorage.getItem('silentStacks_requests', []),
    settings: SafeStorage.getItem('silentStacks_settings', {}),
    currentView: 'table',
    currentSort: { field: 'created', direction: 'desc' },
    selectedRequests: new Set(),
    fuse: null,
    rateLimit: new RateLimit(15, 60000)
};

// Value mappings for dirty data processing
const VALUE_MAPPINGS = {
    priority: {
        'rush': 'urgent', 'immediate': 'urgent', 'medium': 'normal', 'routine': 'normal',
        'low': 'low', 'normal': 'normal', 'high': 'high', 'urgent': 'urgent'
    },
    status: {
        'pending': 'order', 'complete': 'completed', 'canceled': 'cancelled', 'cancelled': 'cancelled',
        'order': 'order', 'received': 'received', 'processing': 'processing', 'completed': 'completed'
    }
};

let requestIdCounter = parseInt(SafeStorage.getItem('silentStacks_counter', '1'));

// DOM Selectors
const S = {
    buttons: {
        lookup_pmid: "#lookup-pmid", lookup_doi: "#lookup-doi", lookup_nct: "#lookup-nct",
        bulk_paste: "#bulk-paste-btn", bulk_upload: "#bulk-upload-btn"
    },
    inputs: {
        pmid: "#pmid", doi: "#doi", nct: "#nct", title: "#title", authors: "#authors",
        journal: "#journal", year: "#year", volume: "#volume", pages: "#pages",
        tags_text: "#tags", patron: "#patron-email", status: "#status", priority: "#priority", docline: "#docline"
    },
    clinical_trials: {
        phase: "#gl-phase", status: "#gl-ct-status", sponsor: "#gl-sponsor", nct_title: "#gl-nct-title"
    },
    chips: { mesh: "#gl-chips" },
    bulk: { paste_textarea: "#bulk-paste-data", upload_input: "#bulk-upload" },
    status_regions: { live: "#ss-live", pmid: "#pmid-status", doi: "#doi-status", nct: "#nct-status" }
};

// Enhanced PMID Enrichment Pipeline with Security
class PMIDEnrichmentPipeline {
    constructor(options = {}) {
        this.apiKey = options.apiKey || '';
        this.crossrefEmail = options.crossrefEmail || '';
        this.rateLimit = APP_STATE.rateLimit;
    }

    async enrichPMID(pmid) {
        // Security validation
        if (!SecurityUtils.isValidPMID(pmid)) {
            throw new Error('Invalid PMID format');
        }
        
        // Rate limiting
        if (!this.rateLimit.canMakeRequest()) {
            throw new Error('Rate limit exceeded. Please wait before making more requests.');
        }

        // Demo data for testing (security validated)
        if (pmid === '18539917') {
            return {
                status: 'complete',
                unified: {
                    pmid: pmid,
                    title: SecurityUtils.sanitizeHtml('Sorafenib in patients with advanced hepatocellular carcinoma: a randomized, double-blind, placebo-controlled phase 3 trial'),
                    authors: 'Llovet JM; Ricci S; Mazzaferro V; et al.',
                    journal: 'New England Journal of Medicine',
                    year: '2008', volume: '359', pages: '378-90',
                    doi: '10.1056/NEJMoa0803399', nct: 'NCT00048516',
                    clinicalTrial: {
                        nctId: 'NCT00048516',
                        title: 'Sorafenib in Patients With Advanced Hepatocellular Carcinoma',
                        phase: 'III', status: 'Completed',
                        sponsor: 'Bayer Healthcare Pharmaceuticals'
                    },
                    tags: [
                        { name: 'Hepatocellular Carcinoma', type: 'mesh' },
                        { name: 'Antineoplastic Agents', type: 'mesh' },
                        { name: 'Sorafenib', type: 'mesh' },
                        { name: 'Phase III', type: 'trial' },
                        { name: 'Randomized Controlled Trial', type: 'mesh' }
                    ]
                }
            };
        }

        if (pmid === '23842776') {
            return {
                status: 'complete',
                unified: {
                    pmid: pmid,
                    title: SecurityUtils.sanitizeHtml('Single-cell RNA-seq reveals dynamic paracrine control of cellular variation'),
                    authors: 'Shalek AK; Satija R; Adiconis X; et al.',
                    journal: 'Cell', year: '2013', volume: '154', pages: '1395-408',
                    doi: '10.1016/j.cell.2013.06.020',
                    tags: [
                        { name: 'Single-Cell Analysis', type: 'mesh' },
                        { name: 'RNA-Seq', type: 'mesh' },
                        { name: 'Gene Expression Profiling', type: 'mesh' },
                        { name: 'Transcriptome', type: 'mesh' }
                    ]
                }
            };
        }

        throw new Error('CORS: Use demo PMIDs 18539917 or 23842776');
    }

    async enrichDOI(doi) {
        if (!SecurityUtils.isValidDOI(doi)) {
            throw new Error('Invalid DOI format');
        }
        
        if (!this.rateLimit.canMakeRequest()) {
            throw new Error('Rate limit exceeded');
        }

        if (doi === '10.1056/NEJMoa0803399') {
            return {
                status: 'complete',
                unified: {
                    doi: doi,
                    title: SecurityUtils.sanitizeHtml('Sorafenib in patients with advanced hepatocellular carcinoma'),
                    authors: 'Llovet JM; Ricci S; Mazzaferro V; et al.',
                    journal: 'New England Journal of Medicine',
                    year: '2008',
                    tags: [
                        { name: 'Hepatocellular Carcinoma', type: 'mesh' },
                        { name: 'Antineoplastic Agents', type: 'mesh' }
                    ]
                }
            };
        }
        throw new Error('CORS: Use demo DOI 10.1056/NEJMoa0803399');
    }

    async enrichNCT(nct) {
        if (!SecurityUtils.isValidNCT(nct)) {
            throw new Error('Invalid NCT format');
        }
        
        if (!this.rateLimit.canMakeRequest()) {
            throw new Error('Rate limit exceeded');
        }

        if (nct === 'NCT00048516') {
            return {
                status: 'complete',
                unified: {
                    nct: nct,
                    title: SecurityUtils.sanitizeHtml('Sorafenib vs Placebo in Advanced Hepatocellular Carcinoma'),
                    clinicalTrial: {
                        nctId: nct,
                        title: 'Sorafenib in Patients With Advanced Hepatocellular Carcinoma',
                        phase: 'III', status: 'Completed',
                        sponsor: 'Bayer Healthcare Pharmaceuticals'
                    },
                    tags: [
                        { name: 'Phase III', type: 'phase' },
                        { name: 'Hepatocellular Carcinoma', type: 'condition' }
                    ]
                }
            };
        }
        throw new Error('CORS: Use demo NCT NCT00048516');
    }
}

// Utility Functions
const $ = s => document.querySelector(s);
const $$ = s => Array.from(document.querySelectorAll(s));
const setVal = (sel, v) => $$(sel).forEach(el => { 
    if ('value' in el) el.value = SecurityUtils.sanitizeHtml(v ?? '');
    else el.textContent = SecurityUtils.sanitizeHtml(v ?? '');
});
const getVal = sel => { 
    const el = $(sel); 
    return el ? ('value' in el ? SecurityUtils.sanitizeHtml(el.value) : SecurityUtils.sanitizeHtml(el.textContent)) : ''; 
};
const say = (sel, msg) => setVal(sel, msg);

// Global engine instance
const engine = new PMIDEnrichmentPipeline({
    apiKey: APP_STATE.settings.apiKey || '',
    crossrefEmail: APP_STATE.settings.crossrefEmail || ''
});

function normAuthors(a) {
    return Array.isArray(a) ? a.map(x => x.name || x.family || x.last || x).join('; ') : (a || '');
}

function announceToScreenReader(message) {
    const liveRegion = document.getElementById('ss-live');
    if (liveRegion) {
        liveRegion.textContent = SecurityUtils.sanitizeHtml(message);
    }
}

// Enhanced data cleaning and validation with security
function cleanAndValidateData(data) {
    const cleaned = { ...data };
    
    // Clean priority values
    if (cleaned.priority) {
        cleaned.priority = VALUE_MAPPINGS.priority[cleaned.priority.toLowerCase()] || cleaned.priority;
    }
    
    // Clean status values  
    if (cleaned.status) {
        cleaned.status = VALUE_MAPPINGS.status[cleaned.status.toLowerCase()] || cleaned.status;
    }
    
    // Validate and clean email
    if (cleaned.patronEmail) {
        cleaned.patronEmail = SecurityUtils.sanitizeHtml(cleaned.patronEmail);
        if (!SecurityUtils.isValidEmail(cleaned.patronEmail)) {
            console.warn('Invalid email format:', cleaned.patronEmail);
        }
    }
    
    // Clean PMID (digits only)
    if (cleaned.pmid) {
        cleaned.pmid = cleaned.pmid.toString().replace(/\D/g, '');
        if (!SecurityUtils.isValidPMID(cleaned.pmid)) {
            cleaned.pmid = '';
        }
    }
    
    // Clean DOI format
    if (cleaned.doi) {
        cleaned.doi = SecurityUtils.sanitizeHtml(cleaned.doi);
        if (!SecurityUtils.isValidDOI(cleaned.doi)) {
            console.warn('Invalid DOI format:', cleaned.doi);
        }
    }
    
    // Clean NCT format
    if (cleaned.nct) {
        cleaned.nct = cleaned.nct.toUpperCase();
        if (!SecurityUtils.isValidNCT(cleaned.nct)) {
            cleaned.nct = '';
        }
    }
    
    // Validate year range
    if (cleaned.year) {
        const year = parseInt(cleaned.year);
        if (year < 1900 || year > 2030) {
            console.warn('Year out of range:', cleaned.year);
        }
    }
    
    // Clean author formatting
    if (cleaned.authors) {
        cleaned.authors = SecurityUtils.sanitizeHtml(cleaned.authors);
        cleaned.authors = cleaned.authors.replace(/,\s*et\s+al\.?/gi, ', et al');
        cleaned.authors = cleaned.authors.replace(/;\s*and\s+/gi, '; ');
    }
    
    // Sanitize all text fields
    ['title', 'journal', 'volume', 'pages', 'tags', 'notes'].forEach(field => {
        if (cleaned[field]) {
            cleaned[field] = SecurityUtils.sanitizeHtml(cleaned[field]);
        }
    });
    
    return cleaned;
}

// Data quality validation with security
function validateDataQuality() {
    const issues = [];
    const duplicates = new Map();
    
    APP_STATE.requests.forEach((req, index) => {
        // Check for missing critical fields
        if (!req.title || req.title === 'Untitled') {
            issues.push(`Row ${index + 1}: Missing title`);
        }
        if (!req.patronEmail) {
            issues.push(`Row ${index + 1}: Missing patron email`);
        }
        
        // Check for suspicious data
        if (req.year && (parseInt(req.year) < 1900 || parseInt(req.year) > 2030)) {
            issues.push(`Row ${index + 1}: Suspicious year: ${req.year}`);
        }
        
        // Check for duplicates
        if (req.docline) {
            if (duplicates.has(req.docline)) {
                issues.push(`Row ${index + 1}: Duplicate DOCLINE: ${req.docline}`);
            } else {
                duplicates.set(req.docline, index + 1);
            }
        }
        
        // Check email format
        if (req.patronEmail && !SecurityUtils.isValidEmail(req.patronEmail)) {
            issues.push(`Row ${index + 1}: Invalid email format: ${req.patronEmail}`);
        }
        
        // Check for potential security issues
        if (req.title && req.title.includes('<script')) {
            issues.push(`Row ${index + 1}: Potential security issue in title`);
        }
    });
    
    // Generate report
    const reportContent = `SilentStacks Data Quality Report
Generated: ${new Date().toLocaleString()}
Total Records: ${APP_STATE.requests.length}
Issues Found: ${issues.length}

${issues.length === 0 ? 'No issues found! Data quality is excellent.' : 
  'Issues Detected:\n' + issues.map((issue, i) => `${i + 1}. ${issue}`).join('\n')}

Summary:
- Duplicate DOCLINE entries: ${issues.filter(i => i.includes('Duplicate DOCLINE')).length}
- Missing titles: ${issues.filter(i => i.includes('Missing title')).length}
- Missing emails: ${issues.filter(i => i.includes('Missing patron email')).length}
- Invalid emails: ${issues.filter(i => i.includes('Invalid email')).length}
- Suspicious years: ${issues.filter(i => i.includes('Suspicious year')).length}
- Security issues: ${issues.filter(i => i.includes('security issue')).length}`.trim();
    
    downloadFile('silentstacks-data-quality-report.txt', reportContent, 'text/plain');
    announceToScreenReader(`Data quality report generated: ${issues.length} issues found`);
}

// Enhanced DOCLINE validation with UI feedback
function setupDoclineValidation() {
    const doclineInput = document.getElementById('docline');
    if (!doclineInput) return;
    
    doclineInput.addEventListener('input', function() {
        const value = SecurityUtils.sanitizeHtml(this.value.trim());
        const editId = document.getElementById('requestForm').dataset.editId;
        
        if (!value) {
            this.style.borderColor = '';
            this.title = '';
            return;
        }
        
        if (validateDoclineUnique(value, editId)) {
            this.style.borderColor = '#10b981';
            this.title = 'DOCLINE number is available';
        } else {
            this.style.borderColor = '#ef4444';
            this.title = 'DOCLINE number already exists';
        }
    });
}

function fillTrial(ct) {
    if (!ct) return;
    setVal(S.clinical_trials.phase, ct.phase || '');
    setVal(S.clinical_trials.status, ct.status || '');
    setVal(S.clinical_trials.sponsor, ct.sponsor || '');
    if (ct.title) setVal(S.clinical_trials.nct_title, ct.title);
}

function renderChips(tags) {
    if (!tags) return;
    const containers = $$(S.chips.mesh);
    if (!containers.length) return;
    
    containers.forEach(c => {
        c.classList.remove('hidden');
        c.querySelectorAll('[data-auto="true"]').forEach(x => x.remove());
        
        tags.slice(0, 8).forEach(tag => {
            const chip = document.createElement('span');
            const tagName = typeof tag === 'string' ? tag : tag.name;
            let tagType = typeof tag === 'object' ? tag.type : 'mesh';
            
            // Enhanced: Auto-categorize tag types based on content
            if (tagType === 'mesh') {
                const tagLower = tagName.toLowerCase();
                if (tagLower.includes('phase') || /phase\s+[ivx]+/i.test(tagName)) {
                    tagType = 'phase';
                } else if (tagLower.includes('trial') || tagLower.includes('study') || tagLower.includes('clinical')) {
                    tagType = 'trial';
                } else if (tagLower.includes('carcinoma') || tagLower.includes('disease') || tagLower.includes('syndrome')) {
                    tagType = 'condition';
                } else if (tagLower.includes('drug') || tagLower.includes('therapy') || tagLower.includes('treatment')) {
                    tagType = 'intervention';
                } else if (tagLower.includes('pharmaceuticals') || tagLower.includes('company') || tagLower.includes('inc')) {
                    tagType = 'sponsor';
                }
            }
            
            chip.className = `mesh-tag mesh-tag-${tagType}`;
            chip.dataset.auto = 'true';
            chip.dataset.type = tagType;
            chip.textContent = SecurityUtils.sanitizeHtml(tagName);
            chip.title = `Click to add: ${SecurityUtils.sanitizeHtml(tagName)}`;
            chip.style.cursor = 'pointer';
            
            chip.addEventListener('click', () => {
                addTagToField(tagName);
                chip.style.opacity = '0.5';
                setTimeout(() => { chip.style.opacity = '1'; }, 200);
            });
            
            c.appendChild(chip);
        });
    });
}

function addTagToField(tagName) {
    const tagsField = $(S.inputs.tags_text);
    if (!tagsField) return;
    
    const sanitizedTag = SecurityUtils.sanitizeHtml(tagName);
    const currentTags = tagsField.value.split(',').map(t => t.trim()).filter(Boolean);
    if (!currentTags.includes(sanitizedTag)) {
        currentTags.push(sanitizedTag);
        tagsField.value = currentTags.join(', ');
        announceToScreenReader(`Added tag: ${sanitizedTag}`);
    }
}

function fillForm(u) {
    setVal(S.inputs.title, u.title || '');
    setVal(S.inputs.authors, normAuthors(u.authors) || u.authorString || '');
    setVal(S.inputs.journal, u.journal || u.containerTitle || '');
    setVal(S.inputs.year, u.year || u.publishedYear || '');
    setVal(S.inputs.volume, u.volume || '');
    setVal(S.inputs.pages, u.pages || '');
    setVal(S.inputs.doi, u.doi || '');
    
    const nctVal = u.nct || (u.clinicalTrial && u.clinicalTrial.nctId) || '';
    setVal(S.inputs.nct, nctVal);
    
    if (u.clinicalTrial) fillTrial(u.clinicalTrial);
    renderChips(u.tags || u.mesh);
}

function addRequestRow(u) {
    const requestData = {
        title: u.title || 'Enriched Request',
        authors: normAuthors(u.authors) || '',
        journal: u.journal || '',
        year: u.year || '',
        volume: u.volume || '',
        pages: u.pages || '',
        pmid: u.pmid || '',
        doi: u.doi || '',
        nct: u.nct || '',
        patronEmail: getVal(S.inputs.patron) || '',
        docline: getVal(S.inputs.docline) || '',
        priority: getVal(S.inputs.priority) || 'normal',
        status: getVal(S.inputs.status) || 'order',
        tags: u.tags ? u.tags.map(t => t.name).join(', ') : '',
        notes: u.clinicalTrial ? `Clinical trial: ${u.clinicalTrial.nctId || u.nct}` : ''
    };
    
    saveRequest(requestData);
}

async function route(token, kind, prePopulatedData = null) {
    try {
        let res;
        let u = {};
        
        // Enhanced: Use pre-populated data if available (from CSV)
        if (prePopulatedData) {
            u = { ...prePopulatedData };
            // Still try to enrich with API data if we have an identifier
            try {
                if (kind === 'pmid') {
                    res = await engine.enrichPMID(token);
                } else if (kind === 'doi') {
                    res = await engine.enrichDOI(token);
                } else if (kind === 'nct') {
                    res = await engine.enrichNCT(token);
                }
                
                // Merge API data with pre-populated data (pre-populated takes priority)
                if (res?.unified) {
                    u = { ...res.unified, ...prePopulatedData };
                }
            } catch (e) {
                // If API fails, just use pre-populated data
                console.log('API enrichment failed, using pre-populated data:', e.message);
            }
        } else {
            // Original behavior - API lookup only
            if (kind === 'pmid') {
                res = await engine.enrichPMID(token);
            } else if (kind === 'doi') {
                res = await engine.enrichDOI(token);
            } else if (kind === 'nct') {
                res = await engine.enrichNCT(token);
            }
            u = res?.unified || {};
        }
        
        fillForm(u);
        addRequestRow(u);
        return { success: true, hasNCT: !!(u.nct || u.clinicalTrial) };
    } catch (e) {
        console.error('Enrichment failed:', kind, token, e);
        return { success: false, error: e.message };
    }
}

// Data Management Functions
function generateRequestId() {
    return `ILL-${String(requestIdCounter++).padStart(4, '0')}`;
}

function validateDoclineUnique(docline, currentId = null) {
    if (!docline) return true;
    return !APP_STATE.requests.some(req => 
        req.docline === docline && req.id !== currentId
    );
}

function saveRequest(requestData) {
    // Clean and validate data before saving
    const cleanedData = cleanAndValidateData(requestData);
    
    if (cleanedData.docline && !validateDoclineUnique(cleanedData.docline)) {
        announceToScreenReader('Error: DOCLINE number already exists');
        alert('DOCLINE number already exists. Please use a unique DOCLINE number.');
        return null;
    }

    const request = {
        id: generateRequestId(),
        ...cleanedData,
        created: new Date().toISOString(),
        updated: new Date().toISOString()
    };

    APP_STATE.requests.unshift(request);
    SafeStorage.setItem('silentStacks_requests', APP_STATE.requests);
    SafeStorage.setItem('silentStacks_counter', requestIdCounter.toString());
    
    updateDashboardStats();
    renderRequests();
    announceToScreenReader('Request saved successfully');
    
    return request;
}

function deleteRequest(id) {
    if (!confirm('Are you sure you want to delete this request?')) return;

    APP_STATE.requests = APP_STATE.requests.filter(req => req.id !== id);
    SafeStorage.setItem('silentStacks_requests', APP_STATE.requests);
    
    updateDashboardStats();
    renderRequests();
    announceToScreenReader('Request deleted');
}

// Search Functions
function initializeFuseSearch() {
    const fuseOptions = {
        keys: [
            { name: 'title', weight: 0.3 },
            { name: 'authors', weight: 0.2 },
            { name: 'journal', weight: 0.1 },
            { name: 'patronEmail', weight: 0.2 },
            { name: 'tags', weight: 0.1 },
            { name: 'notes', weight: 0.05 },
            { name: 'id', weight: 0.05 }
        ],
        threshold: 0.4,
        includeScore: true,
        minMatchCharLength: 2
    };
    
    APP_STATE.fuse = new Fuse(APP_STATE.requests, fuseOptions);
}

function performFuzzySearch(query) {
    if (!query.trim() || !APP_STATE.fuse) {
        return APP_STATE.requests;
    }
    
    const cleanQuery = SecurityUtils.sanitizeHtml(query);
    const results = APP_STATE.fuse.search(cleanQuery);
    return results.map(result => result.item);
}

// Display Functions
function formatCitation(request) {
    let citation = '';
    
    if (request.authors) {
        const authorList = request.authors.split(';').slice(0, 3);
        citation += authorList.join(', ');
        if (authorList.length >= 3) citation += ', et al';
        citation += '. ';
    }
    
    if (request.title) {
        const title = request.title.length > 80 ? request.title.substring(0, 80) + '...' : request.title;
        citation += title + '. ';
    }
    
    if (request.journal) {
        citation += request.journal + '. ';
    }
    if (request.year) {
        citation += request.year + '.';
    }
    
    return SecurityUtils.sanitizeHtml(citation.trim());
}

function renderRequests() {
    const filteredRequests = filterRequests(APP_STATE.requests);
    const sortedRequests = sortRequests(filteredRequests);

    if (APP_STATE.currentView === 'table') {
        renderTableView(sortedRequests);
    } else {
        renderCardsView(sortedRequests);
    }
}

function filterRequests(requests) {
    const searchTerm = document.getElementById('searchInput')?.value || '';
    const statusFilter = document.getElementById('statusFilter')?.value || '';
    const priorityFilter = document.getElementById('priorityFilter')?.value || '';
    
    let filteredRequests = requests;
    
    if (searchTerm.trim()) {
        filteredRequests = performFuzzySearch(searchTerm);
    }
    
    return filteredRequests.filter(request => {
        const matchesStatus = !statusFilter || request.status === statusFilter;
        const matchesPriority = !priorityFilter || request.priority === priorityFilter;
        return matchesStatus && matchesPriority;
    });
}

function sortRequests(requests) {
    const { field, direction } = APP_STATE.currentSort;
    
    return [...requests].sort((a, b) => {
        let aVal = a[field] || '';
        let bVal = b[field] || '';

        if (field === 'created' || field === 'updated') {
            aVal = new Date(aVal);
            bVal = new Date(bVal);
        }

        if (aVal < bVal) return direction === 'asc' ? -1 : 1;
        if (aVal > bVal) return direction === 'asc' ? 1 : -1;
        return 0;
    });
}

function renderTableView(requests) {
    const tbody = document.querySelector('#requests-table tbody');
    if (!tbody) return;

    tbody.innerHTML = '';

    requests.forEach(request => {
        const row = document.createElement('tr');
        const citation = formatCitation(request);
        const lastUpdated = new Date(request.updated || request.created).toLocaleDateString();
        
        row.innerHTML = `
            <td class="checkbox-cell">
                <input type="checkbox" value="${SecurityUtils.sanitizeHtml(request.id)}" onchange="selectRequest('${SecurityUtils.sanitizeHtml(request.id)}', this.checked)">
            </td>
            <td><span class="priority-badge ${request.priority || 'normal'}">${SecurityUtils.sanitizeHtml((request.priority || 'normal').toUpperCase())}</span></td>
            <td>${SecurityUtils.sanitizeHtml(request.docline || 'N/A')}</td>
            <td>${SecurityUtils.sanitizeHtml(request.pmid || 'N/A')}</td>
            <td title="${SecurityUtils.sanitizeHtml(request.title || 'Untitled')}">${citation || 'No citation available'}</td>
            <td>${SecurityUtils.sanitizeHtml(request.patronEmail || 'N/A')}</td>
            <td><span class="status-badge ${request.status || 'order'}">${SecurityUtils.sanitizeHtml(request.status || 'order')}</span></td>
            <td>${SecurityUtils.sanitizeHtml(lastUpdated)}</td>
            <td>
                <button class="btn btn-sm btn-secondary" onclick="editRequest('${SecurityUtils.sanitizeHtml(request.id)}')">Edit</button>
                <button class="btn btn-sm btn-danger" onclick="deleteRequest('${SecurityUtils.sanitizeHtml(request.id)}')">Delete</button>
            </td>
        `;
        tbody.appendChild(row);
    });
}

function renderCardsView(requests) {
    const container = document.getElementById('cardsView');
    if (!container) return;

    container.innerHTML = '';

    requests.forEach(request => {
        const card = document.createElement('div');
        card.className = 'request-card';
        const lastUpdated = new Date(request.updated || request.created).toLocaleDateString();
        card.innerHTML = `
            <div class="request-header">
                <span class="request-id">${SecurityUtils.sanitizeHtml(request.id)}</span>
                <span class="status-badge ${request.status || 'order'}">${SecurityUtils.sanitizeHtml(request.status || 'order')}</span>
            </div>
            <h3 class="request-title">${SecurityUtils.sanitizeHtml(request.title || 'Untitled')}</h3>
            <div class="request-meta">
                <div><strong>Patron:</strong> ${SecurityUtils.sanitizeHtml(request.patronEmail || 'N/A')}</div>
                <div><strong>DOCLINE #:</strong> ${SecurityUtils.sanitizeHtml(request.docline || 'N/A')}</div>
                <div><strong>PMID:</strong> ${SecurityUtils.sanitizeHtml(request.pmid || 'N/A')}</div>
                <div><strong>Journal:</strong> ${SecurityUtils.sanitizeHtml(request.journal || 'N/A')}</div>
                <div><strong>Year:</strong> ${SecurityUtils.sanitizeHtml(request.year || 'N/A')}</div>
                <div><strong>Urgency:</strong> <span class="priority-badge ${request.priority || 'normal'}">${SecurityUtils.sanitizeHtml((request.priority || 'normal').toUpperCase())}</span></div>
                <div><strong>Last Updated:</strong> ${SecurityUtils.sanitizeHtml(lastUpdated)}</div>
            </div>
            <div class="request-actions">
                <button class="btn btn-sm btn-secondary" onclick="editRequest('${SecurityUtils.sanitizeHtml(request.id)}')">Edit</button>
                <button class="btn btn-sm btn-danger" onclick="deleteRequest('${SecurityUtils.sanitizeHtml(request.id)}')">Delete</button>
            </div>
        `;
        container.appendChild(card);
    });
}

// Bulk Operations with Security
function parseIdentifiers(text) {
    const cleanText = SecurityUtils.sanitizeHtml(text);
    const identifiers = [];
    
    const pmids = cleanText.match(/\b\d{6,9}\b/g) || [];
    pmids.forEach(pmid => {
        if (SecurityUtils.isValidPMID(pmid)) {
            identifiers.push({ token: pmid, kind: 'pmid' });
        }
    });
    
    const dois = cleanText.match(/\b10\.[^\s"']+\b/g) || [];
    dois.forEach(doi => {
        if (SecurityUtils.isValidDOI(doi)) {
            identifiers.push({ token: doi, kind: 'doi' });
        }
    });
    
    const ncts = cleanText.match(/\bNCT\d{8}\b/gi) || [];
    ncts.forEach(nct => {
        if (SecurityUtils.isValidNCT(nct)) {
            identifiers.push({ token: nct.toUpperCase(), kind: 'nct' });
        }
    });

    const seen = new Set();
    return identifiers.filter(item => {
        const key = `${item.kind}:${item.token}`;
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
    });
}

async function processBulkPaste() {
    const textarea = $(S.bulk.paste_textarea);
    if (!textarea) return;
    
    const text = textarea.value || '';
    const tokens = text.match(/\b(NCT\d{8}|10\.[^\s"']+|\d{6,9})\b/gi) || [];
    
    if (tokens.length === 0) {
        announceToScreenReader('No valid identifiers found');
        return;
    }

    const seen = new Set();
    const queue = [];
    
    for (const t of tokens) {
        const token = SecurityUtils.sanitizeHtml(t.trim());
        if (seen.has(token)) continue;
        seen.add(token);
        
        const kind = /^NCT/i.test(token) ? 'nct' : /^10\./.test(token) ? 'doi' : 'pmid';
        
        // Validate token before adding to queue
        if ((kind === 'pmid' && SecurityUtils.isValidPMID(token)) ||
            (kind === 'doi' && SecurityUtils.isValidDOI(token)) ||
            (kind === 'nct' && SecurityUtils.isValidNCT(token))) {
            queue.push({ token, kind });
        }
    }

    if (queue.length === 0) {
        announceToScreenReader('No valid identifiers found after validation');
        return;
    }

    announceToScreenReader(`Processing ${queue.length} identifiers...`);
    
    let processed = 0;
    for (const { token, kind } of queue) {
        try {
            await route(token, kind);
            processed++;
            announceToScreenReader(`Processed ${processed}/${queue.length}: ${token}`);
        } catch (error) {
            console.error('Failed to process:', token, error);
        }
        
        await new Promise(r => setTimeout(r, 500));
    }

    announceToScreenReader(`Bulk paste complete: ${processed} requests created`);
    textarea.value = '';
}

async function processBulkUpload() {
    const fileInput = $(S.bulk.upload_input);
    const file = fileInput?.files?.[0];
    
    if (!file) {
        announceToScreenReader('Please select a file first');
        return;
    }
    
    // Security validation
    if (!SecurityUtils.isValidFileType(file.name)) {
        announceToScreenReader('Invalid file type. Only CSV, JSON, and TXT files are allowed.');
        return;
    }
    
    if (!SecurityUtils.isValidFileSize(file, 10)) {
        announceToScreenReader('File size too large. Maximum 10MB allowed.');
        return;
    }
    
    try {
        let identifiers = [];
        
        if (file.name.toLowerCase().endsWith('.csv')) {
            announceToScreenReader('Processing CSV file...');
            const text = await file.text();
            const csvData = Papa.parse(text, {
                header: true,
                skipEmptyLines: true,
                dynamicTyping: true
            });
            identifiers = extractIdentifiersFromCSV(csvData.data);
        } else if (file.name.toLowerCase().endsWith('.json')) {
            announceToScreenReader('Processing JSON file...');
            const text = await file.text();
            const json = JSON.parse(text);
            
            if (json.pmids) identifiers.push(...json.pmids.map(p => ({ token: String(p), kind: 'pmid' })));
            if (json.dois) identifiers.push(...json.dois.map(d => ({ token: String(d), kind: 'doi' })));
            if (json.ncts) identifiers.push(...json.ncts.map(n => ({ token: String(n), kind: 'nct' })));
            
            if (Array.isArray(json)) {
                json.forEach(item => {
                    if (item.pmid) identifiers.push({ token: String(item.pmid), kind: 'pmid' });
                    if (item.doi) identifiers.push({ token: String(item.doi), kind: 'doi' });
                    if (item.nct) identifiers.push({ token: String(item.nct), kind: 'nct' });
                });
            }
        } else {
            announceToScreenReader('Processing text file...');
            const text = await file.text();
            identifiers = parseIdentifiers(text);
        }
        
        if (identifiers.length === 0) {
            announceToScreenReader('No valid identifiers found in file');
            return;
        }
        
        announceToScreenReader(`Found ${identifiers.length} identifiers. Processing...`);
        
        let processed = 0;
        for (const { token, kind, rowData } of identifiers) {
            try {
                await route(token.trim(), kind, rowData);
                processed++;
                announceToScreenReader(`Processed ${processed}/${identifiers.length}: ${token}`);
            } catch (error) {
                console.error('Failed to process:', token, error);
            }
            
            await new Promise(r => setTimeout(r, 300));
        }
        
        announceToScreenReader(`Bulk upload complete: ${processed} requests created`);
        fileInput.value = '';
        
    } catch (error) {
        console.error('Bulk upload failed:', error);
        announceToScreenReader('Bulk upload failed: ' + error.message);
    }
}

function extractIdentifiersFromCSV(csvData) {
    const identifiers = [];
    let cleanedRecords = 0;
    
    const headers = Object.keys(csvData[0] || {}).map(h => h.toLowerCase().replace(/\s+/g, ''));
    const pmidColumns = headers.filter(h => ['pmid', 'pubmedid', 'pm_id'].includes(h));
    const doiColumns = headers.filter(h => ['doi'].includes(h));
    const nctColumns = headers.filter(h => ['nct', 'nctid', 'clinicaltrialsid'].includes(h));
    
    // Enhanced: Look for pre-populated bibliographic data
    const titleColumns = headers.filter(h => ['title', 'articletitle', 'citation'].includes(h));
    const authorColumns = headers.filter(h => ['authors', 'author', 'authorlist'].includes(h));
    const journalColumns = headers.filter(h => ['journal', 'journalname', 'publication'].includes(h));
    const yearColumns = headers.filter(h => ['year', 'publicationyear', 'pubyear'].includes(h));
    const emailColumns = headers.filter(h => ['email', 'patronemail', 'requesteremail'].includes(h));
    const priorityColumns = headers.filter(h => ['priority', 'urgency', 'rush'].includes(h));
    const statusColumns = headers.filter(h => ['status', 'fillstatus', 'state'].includes(h));
    
    csvData.forEach((row, index) => {
        let hasIdentifier = false;
        let rowData = {};
        
        // Extract and validate identifiers
        pmidColumns.forEach(col => {
            const originalCol = Object.keys(row).find(k => k.toLowerCase().replace(/\s+/g, '') === col);
            if (row[originalCol] && SecurityUtils.isValidPMID(String(row[originalCol]))) {
                identifiers.push({ token: String(row[originalCol]), kind: 'pmid', rowData: { ...rowData, pmid: String(row[originalCol]) } });
                hasIdentifier = true;
            }
        });
        
        doiColumns.forEach(col => {
            const originalCol = Object.keys(row).find(k => k.toLowerCase().replace(/\s+/g, '') === col);
            if (row[originalCol] && SecurityUtils.isValidDOI(String(row[originalCol]))) {
                identifiers.push({ token: String(row[originalCol]), kind: 'doi', rowData: { ...rowData, doi: String(row[originalCol]) } });
                hasIdentifier = true;
            }
        });
        
        nctColumns.forEach(col => {
            const originalCol = Object.keys(row).find(k => k.toLowerCase().replace(/\s+/g, '') === col);
            if (row[originalCol] && SecurityUtils.isValidNCT(String(row[originalCol]))) {
                identifiers.push({ token: String(row[originalCol]).toUpperCase(), kind: 'nct', rowData: { ...rowData, nct: String(row[originalCol]).toUpperCase() } });
                hasIdentifier = true;
            }
        });
        
        // Enhanced: Extract bibliographic data for pre-population (with sanitization)
        titleColumns.forEach(col => {
            const originalCol = Object.keys(row).find(k => k.toLowerCase().replace(/\s+/g, '') === col);
            if (row[originalCol]) rowData.title = SecurityUtils.sanitizeHtml(String(row[originalCol]));
        });
        
        authorColumns.forEach(col => {
            const originalCol = Object.keys(row).find(k => k.toLowerCase().replace(/\s+/g, '') === col);
            if (row[originalCol]) rowData.authors = SecurityUtils.sanitizeHtml(String(row[originalCol]));
        });
        
        journalColumns.forEach(col => {
            const originalCol = Object.keys(row).find(k => k.toLowerCase().replace(/\s+/g, '') === col);
            if (row[originalCol]) rowData.journal = SecurityUtils.sanitizeHtml(String(row[originalCol]));
        });
        
        yearColumns.forEach(col => {
            const originalCol = Object.keys(row).find(k => k.toLowerCase().replace(/\s+/g, '') === col);
            if (row[originalCol]) rowData.year = SecurityUtils.sanitizeHtml(String(row[originalCol]));
        });
        
        emailColumns.forEach(col => {
            const originalCol = Object.keys(row).find(k => k.toLowerCase().replace(/\s+/g, '') === col);
            if (row[originalCol]) {
                const email = SecurityUtils.sanitizeHtml(String(row[originalCol]));
                if (SecurityUtils.isValidEmail(email)) {
                    rowData.patronEmail = email;
                }
            }
        });
        
        priorityColumns.forEach(col => {
            const originalCol = Object.keys(row).find(k => k.toLowerCase().replace(/\s+/g, '') === col);
            if (row[originalCol]) rowData.priority = SecurityUtils.sanitizeHtml(String(row[originalCol]));
        });
        
        statusColumns.forEach(col => {
            const originalCol = Object.keys(row).find(k => k.toLowerCase().replace(/\s+/g, '') === col);
            if (row[originalCol]) rowData.status = SecurityUtils.sanitizeHtml(String(row[originalCol]));
        });
        
        // Enhanced: Create records even without identifiers if we have title/authors
        if (!hasIdentifier && (rowData.title || rowData.authors)) {
            const cleanedData = cleanAndValidateData(rowData);
            saveRequest(cleanedData);
            cleanedRecords++;
        }
        
        // Enhanced: Update existing identifiers with pre-populated data
        if (hasIdentifier) {
            identifiers.forEach(item => {
                if (item.rowData && Object.keys(rowData).length > 1) {
                    item.rowData = { ...item.rowData, ...rowData };
                }
            });
        }
        
        // Fallback: regex extraction if no column headers found
        if (pmidColumns.length === 0 && doiColumns.length === 0 && nctColumns.length === 0 && !hasIdentifier) {
            Object.values(row).forEach(value => {
                if (!value) return;
                const str = SecurityUtils.sanitizeHtml(String(value));
                
                const pmidMatch = str.match(/\b\d{6,9}\b/);
                if (pmidMatch && SecurityUtils.isValidPMID(pmidMatch[0])) {
                    identifiers.push({ token: pmidMatch[0], kind: 'pmid', rowData });
                }
                
                const doiMatch = str.match(/\b10\.[^\s"']+\b/);
                if (doiMatch && SecurityUtils.isValidDOI(doiMatch[0])) {
                    identifiers.push({ token: doiMatch[0], kind: 'doi', rowData });
                }
                
                const nctMatch = str.match(/\bNCT\d{8}\b/i);
                if (nctMatch && SecurityUtils.isValidNCT(nctMatch[0])) {
                    identifiers.push({ token: nctMatch[0].toUpperCase(), kind: 'nct', rowData });
                }
            });
        }
    });
    
    if (cleanedRecords > 0) {
        announceToScreenReader(`Data cleaning applied to ${cleanedRecords} records`);
    }
    
    const seen = new Set();
    return identifiers.filter(item => {
        const key = `${item.kind}:${item.token}`;
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
    });
}

// Bulk Selection Functions
function updateBulkActions() {
    const selected = APP_STATE.selectedRequests.size;
    const bulkActions = document.getElementById('bulkActions');
    const bulkActionsText = document.getElementById('bulkActionsText');
    
    if (selected > 0) {
        bulkActions.classList.add('show');
        bulkActionsText.textContent = `${selected} selected`;
    } else {
        bulkActions.classList.remove('show');
    }
}

function selectAllRequests() {
    const checkboxes = document.querySelectorAll('tbody input[type="checkbox"]');
    const selectAll = document.getElementById('selectAll');
    
    checkboxes.forEach(checkbox => {
        checkbox.checked = selectAll.checked;
        if (selectAll.checked) {
            APP_STATE.selectedRequests.add(checkbox.value);
        } else {
            APP_STATE.selectedRequests.delete(checkbox.value);
        }
    });
    
    updateBulkActions();
}

function selectRequest(requestId, checked) {
    const cleanId = SecurityUtils.sanitizeHtml(requestId);
    if (checked) {
        APP_STATE.selectedRequests.add(cleanId);
    } else {
        APP_STATE.selectedRequests.delete(cleanId);
    }
    
    const totalCheckboxes = document.querySelectorAll('tbody input[type="checkbox"]').length;
    const selectAll = document.getElementById('selectAll');
    
    if (APP_STATE.selectedRequests.size === totalCheckboxes && totalCheckboxes > 0) {
        selectAll.checked = true;
        selectAll.indeterminate = false;
    } else if (APP_STATE.selectedRequests.size > 0) {
        selectAll.checked = false;
        selectAll.indeterminate = true;
    } else {
        selectAll.checked = false;
        selectAll.indeterminate = false;
    }
    
    updateBulkActions();
}

function bulkDeleteRequests() {
    if (APP_STATE.selectedRequests.size === 0) return;
    
    if (!confirm(`Are you sure you want to delete ${APP_STATE.selectedRequests.size} selected request(s)?`)) {
        return;
    }
    
    APP_STATE.requests = APP_STATE.requests.filter(req => !APP_STATE.selectedRequests.has(req.id));
    SafeStorage.setItem('silentStacks_requests', APP_STATE.requests);
    
    APP_STATE.selectedRequests.clear();
    updateBulkActions();
    renderRequests();
    updateDashboardStats();
    
    announceToScreenReader('Selected requests deleted');
}

function bulkEditRequests() {
    if (APP_STATE.selectedRequests.size === 0) return;
    alert(`Bulk edit functionality for ${APP_STATE.selectedRequests.size} requests would be implemented here`);
}

function cancelBulkSelection() {
    APP_STATE.selectedRequests.clear();
    document.querySelectorAll('input[type="checkbox"]').forEach(cb => {
        cb.checked = false;
        cb.indeterminate = false;
    });
    updateBulkActions();
}

// Export Functions with Security
function exportToCSV() {
    const headers = ['Urgency', 'DOCLINE #', 'PMID', 'Citation', 'Patron e-mail', 'Fill Status', 'Time Stamp of Last Update'];
    const rows = APP_STATE.requests.map(req => [
        SecurityUtils.sanitizeHtml(req.priority || 'N/A'),
        SecurityUtils.sanitizeHtml(req.docline || 'N/A'), 
        SecurityUtils.sanitizeHtml(req.pmid || 'N/A'),
        formatCitation(req) || 'No citation available',
        SecurityUtils.sanitizeHtml(req.patronEmail || 'N/A'),
        SecurityUtils.sanitizeHtml(req.status || 'N/A'),
        SecurityUtils.sanitizeHtml(req.updated || req.created || 'N/A')
    ]);

    const csv = Papa.unparse({
        fields: headers,
        data: rows
    });

    downloadFile('silentstacks-requests.csv', csv, 'text/csv');
    announceToScreenReader('CSV export downloaded');
}

function exportToJSON() {
    const cleanedRequests = APP_STATE.requests.map(req => ({
        id: SecurityUtils.sanitizeHtml(req.id || 'N/A'),
        urgency: SecurityUtils.sanitizeHtml(req.priority || 'N/A'),
        docline: SecurityUtils.sanitizeHtml(req.docline || 'N/A'),
        pmid: SecurityUtils.sanitizeHtml(req.pmid || 'N/A'),
        citation: formatCitation(req) || 'No citation available',
        patronEmail: SecurityUtils.sanitizeHtml(req.patronEmail || 'N/A'),
        fillStatus: SecurityUtils.sanitizeHtml(req.status || 'N/A'),
        lastUpdated: SecurityUtils.sanitizeHtml(req.updated || req.created || 'N/A'),
        title: SecurityUtils.sanitizeHtml(req.title || 'N/A'),
        authors: SecurityUtils.sanitizeHtml(req.authors || 'N/A'),
        journal: SecurityUtils.sanitizeHtml(req.journal || 'N/A'),
        year: SecurityUtils.sanitizeHtml(req.year || 'N/A'),
        volume: SecurityUtils.sanitizeHtml(req.volume || 'N/A'),
        pages: SecurityUtils.sanitizeHtml(req.pages || 'N/A'),
        doi: SecurityUtils.sanitizeHtml(req.doi || 'N/A'),
        nct: SecurityUtils.sanitizeHtml(req.nct || 'N/A'),
        tags: SecurityUtils.sanitizeHtml(req.tags || 'N/A'),
        notes: SecurityUtils.sanitizeHtml(req.notes || 'N/A'),
        created: SecurityUtils.sanitizeHtml(req.created || 'N/A')
    }));
    
    const jsonContent = JSON.stringify(cleanedRequests, null, 2);
    downloadFile('silentstacks-requests.json', jsonContent, 'application/json');
    announceToScreenReader('JSON export downloaded');
}

function exportToNLM() {
    if (APP_STATE.requests.length === 0) {
        announceToScreenReader('No requests to export');
        return;
    }

    const nlmCitations = APP_STATE.requests.map(req => {
        let citation = '';
        
        if (req.authors && req.authors !== 'N/A') {
            const authorList = req.authors.split(';').map(author => author.trim()).slice(0, 6);
            if (authorList.length > 0) {
                citation += authorList.join(', ');
                if (authorList.length > 6) citation += ', et al';
                citation += '. ';
            }
        } else {
            citation += '[No authors listed]. ';
        }
        
        if (req.title && req.title !== 'N/A' && req.title !== 'Untitled') {
            let title = req.title.trim();
            if (!title.match(/[.!?]$/)) title += '.';
            citation += title + ' ';
        } else {
            citation += '[Title not available]. ';
        }
        
        if (req.journal && req.journal !== 'N/A') {
            citation += req.journal + '. ';
        } else {
            citation += '[Journal not specified]. ';
        }
        
        if (req.year && req.year !== 'N/A') {
            citation += req.year;
        } else {
            citation += '[Year not available]';
        }
        
        if (req.volume && req.volume !== 'N/A') {
            citation += ';' + req.volume;
        }
        
        if (req.pages && req.pages !== 'N/A') {
            citation += ':' + req.pages;
        }
        
        citation += '.';
        
        if (req.doi && req.doi !== 'N/A') {
            citation += ' doi: ' + req.doi + '.';
        }
        
        if (req.pmid && req.pmid !== 'N/A') {
            citation += ' PMID: ' + req.pmid + '.';
        }
        
        return SecurityUtils.sanitizeHtml(citation);
    }).join('\n\n');

    downloadFile('silentstacks-nlm-citations.txt', nlmCitations, 'text/plain');
    announceToScreenReader('NLM citations exported');
}

function downloadFile(filename, content, mimeType) {
    const cleanFilename = SecurityUtils.sanitizeHtml(filename);
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = cleanFilename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// UI Functions
function showTab(tabId) {
    const cleanTabId = SecurityUtils.sanitizeHtml(tabId);
    document.querySelectorAll('.nav-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    const activeTab = document.querySelector(`[data-tab="${cleanTabId}"]`);
    if (activeTab) {
        activeTab.classList.add('active');
    }

    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
    });
    const activeContent = document.getElementById(cleanTabId);
    if (activeContent) {
        activeContent.classList.add('active');
    }

    if (window.innerWidth < 1024) {
        document.getElementById('sidebar').classList.remove('open');
    }

    announceToScreenReader(`Switched to ${cleanTabId.replace('-', ' ')} tab`);
}

function toggleSidebar() {
    document.getElementById('sidebar').classList.toggle('open');
}

function sortTable(field) {
    const cleanField = SecurityUtils.sanitizeHtml(field);
    if (APP_STATE.currentSort.field === cleanField) {
        APP_STATE.currentSort.direction = APP_STATE.currentSort.direction === 'asc' ? 'desc' : 'asc';
    } else {
        APP_STATE.currentSort = { field: cleanField, direction: 'asc' };
    }

    document.querySelectorAll('[id^="sort-"]').forEach(el => {
        el.textContent = '';
    });
    
    const indicator = document.getElementById(`sort-${cleanField}`);
    if (indicator) {
        indicator.textContent = APP_STATE.currentSort.direction === 'asc' ? '' : '';
    }

    renderRequests();
}

function editRequest(id) {
    const cleanId = SecurityUtils.sanitizeHtml(id);
    const request = APP_STATE.requests.find(req => req.id === cleanId);
    if (!request) return;

    Object.keys(request).forEach(key => {
        const element = document.getElementById(key === 'patronEmail' ? 'patron-email' : key);
        if (element && request[key] !== undefined) {
            element.value = SecurityUtils.sanitizeHtml(request[key]);
        }
    });

    showTab('add-request');
    document.getElementById('requestForm').dataset.editId = cleanId;
    announceToScreenReader(`Editing request ${cleanId}`);
}

function updateDashboardStats() {
    const total = APP_STATE.requests.length;
    const pending = APP_STATE.requests.filter(r => r.status === 'order').length;
    const inProgress = APP_STATE.requests.filter(r => r.status === 'received' || r.status === 'processing').length;
    const completed = APP_STATE.requests.filter(r => r.status === 'completed').length;
    
    document.getElementById('totalRequests').textContent = total;
    document.getElementById('pendingRequests').textContent = pending;
    document.getElementById('inProgressRequests').textContent = inProgress;
    document.getElementById('completedRequests').textContent = completed;
}

function updateRecentRequests() {
    const recentContainer = document.getElementById('recentRequests');
    if (!recentContainer) return;

    if (APP_STATE.requests.length === 0) {
        recentContainer.innerHTML = '<p style="color: var(--light-gray);">No recent requests</p>';
        return;
    }

    const recent = APP_STATE.requests.slice(0, 5);
    recentContainer.innerHTML = recent.map(req => `
        <div style="padding: 12px; border-bottom: 1px solid var(--border-gray); cursor: pointer;" onclick="editRequest('${SecurityUtils.sanitizeHtml(req.id)}')">
            <div style="font-weight: 500; margin-bottom: 4px;">${SecurityUtils.sanitizeHtml(req.title || 'Untitled')}</div>
            <div style="font-size: 0.85rem; color: var(--light-gray);">
                ${SecurityUtils.sanitizeHtml(req.patronEmail || 'No patron')}  
                <span class="status-badge ${req.status || 'order'}">${SecurityUtils.sanitizeHtml(req.status || 'order')}</span>  
                ${SecurityUtils.sanitizeHtml(new Date(req.created).toLocaleDateString())}
            </div>
        </div>
    `).join('');
}

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Event listeners with security enhancements
document.addEventListener('DOMContentLoaded', function() {
    // Navigation
    document.getElementById('navToggle').addEventListener('click', toggleSidebar);
    
    document.querySelectorAll('.nav-tab').forEach(tab => {
        tab.addEventListener('click', (e) => {
            e.preventDefault();
            const tabId = tab.getAttribute('data-tab');
            if (tabId) {
                showTab(tabId);
            }
        });
    });

    // Single request lookups with enhanced error handling
    $(S.buttons.lookup_pmid)?.addEventListener('click', async () => {
        const v = getVal(S.inputs.pmid).trim();
        if (!SecurityUtils.isValidPMID(v)) {
            say(S.status_regions.pmid, 'PMID must be 69 digits.');
            return;
        }
        
        PerformanceMonitor.startTimer('pmid-lookup');
        say(S.status_regions.pmid, 'Looking up');
        
        const result = await ErrorBoundary.withErrorBoundary(
            () => route(v, 'pmid'),
            () => ({ success: false, error: 'Lookup failed' }),
            'PMID Lookup'
        );
        
        PerformanceMonitor.endTimer('pmid-lookup');
        say(S.status_regions.pmid, result.success ? (result.hasNCT ? 'Success with clinical trial data!' : 'Success!') : `Error: ${result.error}`);
    });

    $(S.buttons.lookup_doi)?.addEventListener('click', async () => {
        const v = getVal(S.inputs.doi).trim();
        if (!SecurityUtils.isValidDOI(v)) {
            say(S.status_regions.doi, 'Please enter a valid DOI starting with 10.');
            return;
        }
        
        PerformanceMonitor.startTimer('doi-lookup');
        say(S.status_regions.doi, 'Looking up');
        
        const result = await ErrorBoundary.withErrorBoundary(
            () => route(v, 'doi'),
            () => ({ success: false, error: 'Lookup failed' }),
            'DOI Lookup'
        );
        
        PerformanceMonitor.endTimer('doi-lookup');
        say(S.status_regions.doi, result.success ? 'Success!' : `Error: ${result.error}`);
    });

    $(S.buttons.lookup_nct)?.addEventListener('click', async () => {
        const v = getVal(S.inputs.nct).trim().toUpperCase();
        if (!SecurityUtils.isValidNCT(v)) {
            say(S.status_regions.nct, 'NCT must be in format NCT00000000.');
            return;
        }
        
        PerformanceMonitor.startTimer('nct-lookup');
        say(S.status_regions.nct, 'Looking up');
        
        const result = await ErrorBoundary.withErrorBoundary(
            () => route(v, 'nct'),
            () => ({ success: false, error: 'Lookup failed' }),
            'NCT Lookup'
        );
        
        PerformanceMonitor.endTimer('nct-lookup');
        say(S.status_regions.nct, result.success ? 'Success!' : `Error: ${result.error}`);
    });

    // Bulk operations with enhanced error handling
    $(S.buttons.bulk_paste)?.addEventListener('click', () => {
        ErrorBoundary.withErrorBoundary(
            processBulkPaste,
            () => announceToScreenReader('Bulk paste operation failed'),
            'Bulk Paste'
        );
    });
    
    $(S.buttons.bulk_upload)?.addEventListener('click', () => {
        ErrorBoundary.withErrorBoundary(
            processBulkUpload,
            () => announceToScreenReader('Bulk upload operation failed'),
            'Bulk Upload'
        );
    });

    // Form submission with enhanced validation
    document.getElementById('requestForm')?.addEventListener('submit', function(e) {
        e.preventDefault();
        
        const editId = this.dataset.editId;
        const requestData = {
            title: getVal(S.inputs.title),
            authors: getVal(S.inputs.authors),
            journal: getVal(S.inputs.journal),
            year: getVal(S.inputs.year),
            volume: getVal(S.inputs.volume),
            pages: getVal(S.inputs.pages),
            pmid: getVal(S.inputs.pmid),
            doi: getVal(S.inputs.doi),
            nct: getVal(S.inputs.nct),
            patronEmail: getVal(S.inputs.patron),
            docline: getVal(S.inputs.docline),
            priority: getVal(S.inputs.priority),
            status: getVal(S.inputs.status),
            tags: getVal(S.inputs.tags_text),
            notes: getVal('#notes')
        };

        // Additional validation
        if (requestData.patronEmail && !SecurityUtils.isValidEmail(requestData.patronEmail)) {
            alert('Please enter a valid email address.');
            return;
        }

        if (requestData.pmid && !SecurityUtils.isValidPMID(requestData.pmid)) {
            alert('Please enter a valid PMID (6-9 digits).');
            return;
        }

        if (requestData.doi && !SecurityUtils.isValidDOI(requestData.doi)) {
            alert('Please enter a valid DOI.');
            return;
        }

        if (requestData.nct && !SecurityUtils.isValidNCT(requestData.nct)) {
            alert('Please enter a valid NCT number.');
            return;
        }

        if (editId) {
            const requestIndex = APP_STATE.requests.findIndex(req => req.id === editId);
            if (requestIndex !== -1) {
                if (requestData.docline && !validateDoclineUnique(requestData.docline, editId)) {
                    alert('DOCLINE number already exists. Please use a unique DOCLINE number.');
                    return;
                }
                
                APP_STATE.requests[requestIndex] = {
                    ...APP_STATE.requests[requestIndex],
                    ...cleanAndValidateData(requestData),
                    updated: new Date().toISOString()
                };
                
                SafeStorage.setItem('silentStacks_requests', APP_STATE.requests);
                delete this.dataset.editId;
                announceToScreenReader('Request updated successfully');
            }
        } else {
            saveRequest(requestData);
        }

        this.reset();
        updateDashboardStats();
        renderRequests();
        showTab('manage-requests');
    });

    // Clear form button
    document.getElementById('clearForm')?.addEventListener('click', function() {
        document.getElementById('requestForm').reset();
        delete document.getElementById('requestForm').dataset.editId;
        $$(S.chips.mesh).forEach(c => {
            c.querySelectorAll('[data-auto="true"]').forEach(x => x.remove());
            c.classList.add('hidden');
        });
    });

    // View toggle
    document.querySelectorAll('.view-toggle button').forEach(btn => {
        btn.addEventListener('click', function() {
            const view = this.dataset.view;
            APP_STATE.currentView = view;
            
            document.querySelectorAll('.view-toggle button').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            
            if (view === 'table') {
                document.getElementById('tableView').classList.remove('hidden');
                document.getElementById('cardsView').classList.add('hidden');
            } else {
                document.getElementById('tableView').classList.add('hidden');
                document.getElementById('cardsView').classList.remove('hidden');
            }
            
            renderRequests();
        });
    });

    // Search functionality with debouncing
    document.getElementById('searchInput')?.addEventListener('input', debounce(() => {
        renderRequests();
    }, 300));

    // Filter functionality
    ['statusFilter', 'priorityFilter'].forEach(filterId => {
        document.getElementById(filterId)?.addEventListener('change', () => {
            renderRequests();
        });
    });

    // Bulk selection
    document.getElementById('selectAll')?.addEventListener('change', selectAllRequests);
    document.getElementById('bulkEdit')?.addEventListener('click', bulkEditRequests);
    document.getElementById('bulkDelete')?.addEventListener('click', bulkDeleteRequests);
    document.getElementById('bulkCancel')?.addEventListener('click', cancelBulkSelection);

    // Export buttons
    document.getElementById('exportCSV')?.addEventListener('click', exportToCSV);
    document.getElementById('exportJSON')?.addEventListener('click', exportToJSON);
    document.getElementById('exportNLM')?.addEventListener('click', exportToNLM);
    document.getElementById('validateData')?.addEventListener('click', validateDataQuality);

    // Settings with validation
    document.getElementById('saveSettings')?.addEventListener('click', function() {
        const apiKey = document.getElementById('api-key')?.value || '';
        const crossrefEmail = document.getElementById('crossref-email')?.value || '';
        
        if (crossrefEmail && !SecurityUtils.isValidEmail(crossrefEmail)) {
            alert('Please enter a valid email address.');
            return;
        }
        
        const settings = {
            apiKey: SecurityUtils.sanitizeHtml(apiKey),
            crossrefEmail: SecurityUtils.sanitizeHtml(crossrefEmail)
        };
        
        APP_STATE.settings = { ...APP_STATE.settings, ...settings };
        SafeStorage.setItem('silentStacks_settings', APP_STATE.settings);
        announceToScreenReader('Settings saved successfully');
    });

    document.getElementById('themeSelect')?.addEventListener('change', function() {
        const theme = SecurityUtils.sanitizeHtml(this.value);
        document.body.dataset.theme = theme;
        SafeStorage.setItem('silentStacks_theme', theme);
    });

    // Data management with security
    document.getElementById('backupData')?.addEventListener('click', function() {
        const backup = {
            requests: APP_STATE.requests,
            settings: APP_STATE.settings,
            counter: requestIdCounter,
            timestamp: new Date().toISOString()
        };
        downloadFile('silentstacks-backup.json', JSON.stringify(backup, null, 2), 'application/json');
        announceToScreenReader('Data backup downloaded');
    });

    document.getElementById('clearData')?.addEventListener('click', function() {
        if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
            localStorage.removeItem('silentStacks_requests');
            localStorage.removeItem('silentStacks_settings');
            localStorage.removeItem('silentStacks_counter');
            location.reload();
        }
    });

    // Load saved theme
    const savedTheme = SafeStorage.getItem('silentStacks_theme', 'light');
    if (savedTheme) {
        document.body.dataset.theme = savedTheme;
        const themeSelect = document.getElementById('themeSelect');
        if (themeSelect) themeSelect.value = savedTheme;
    }

    // Initialize with error handling and performance monitoring
    try {
        PerformanceMonitor.startTimer('app-initialization');
        
        initializeFuseSearch();
        updateDashboardStats();
        updateRecentRequests();
        renderRequests();
        setupDoclineValidation();
        
        // Cleanup old data if needed
        SafeStorage.cleanup();
        
        // Progressive Enhancement: Register Service Worker if supported
        registerServiceWorker();
        
        PerformanceMonitor.endTimer('app-initialization');
        announceToScreenReader('SilentStacks v2.0 initialized successfully');
        
        // Log successful initialization
        console.log(' SilentStacks v2.0 ready for production');
    } catch (error) {
        ErrorBoundary.logError(error, 'Application Initialization');
        announceToScreenReader('Application initialized with warnings');
        console.warn(' SilentStacks v2.0 initialized with warnings - check console for details');
    }
});

// Progressive Enhancement: Service Worker Registration
function registerServiceWorker() {
    // Only register if service workers are supported
    if (!('serviceWorker' in navigator)) {
        console.log(' Service Worker not supported - running in basic offline mode');
        updateNetworkStatus('offline-basic');
        return;
    }
    
    navigator.serviceWorker.register('./sw.js')
        .then(registration => {
            console.log(' Service Worker registered successfully');
            updateNetworkStatus('offline-enhanced');
            
            // Listen for updates
            registration.addEventListener('updatefound', () => {
                const newWorker = registration.installing;
                newWorker.addEventListener('statechange', () => {
                    if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                        // New version available
                        showUpdateNotification();
                    }
                });
            });
        })
        .catch(error => {
            console.log(' Service Worker registration failed - continuing without enhanced offline');
            console.log('Error details:', error.message);
            updateNetworkStatus('offline-basic');
        });
    
    // Listen for messages from service worker
    navigator.serviceWorker.addEventListener('message', event => {
        console.log(' Message from Service Worker:', event.data);
        
        switch (event.data.type) {
            case 'BACKGROUND_SYNC':
                announceToScreenReader('Syncing data in background');
                break;
        }
    });
}

// Update network status indicator
function updateNetworkStatus(mode) {
    const statusElement = document.getElementById('networkStatus');
    if (!statusElement) return;
    
    switch (mode) {
        case 'offline-enhanced':
            statusElement.textContent = ' Enhanced Offline';
            statusElement.style.color = '#10b981';
            statusElement.title = 'Service Worker active - enhanced offline capabilities';
            break;
        case 'offline-basic':
            statusElement.textContent = ' Basic Offline';
            statusElement.style.color = '#f59e0b';
            statusElement.title = 'Basic offline mode - some features limited without internet';
            break;
        case 'online':
            statusElement.textContent = ' Online';
            statusElement.style.color = '#10b981';
            statusElement.title = 'Connected to internet';
            break;
        default:
            statusElement.textContent = ' Unknown';
            statusElement.style.color = '#6b7280';
    }
}

// Show update notification when new version available
function showUpdateNotification() {
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #3b82f6;
        color: white;
        padding: 16px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 1000;
        max-width: 300px;
    `;
    
    notification.innerHTML = `
        <div style="font-weight: 500; margin-bottom: 8px;">Update Available</div>
        <div style="font-size: 0.9rem; margin-bottom: 12px;">A new version of SilentStacks is ready.</div>
        <button onclick="window.location.reload()" style="background: white; color: #3b82f6; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-weight: 500;">
            Update Now
        </button>
        <button onclick="this.parentElement.remove()" style="background: transparent; color: white; border: 1px solid white; padding: 6px 12px; border-radius: 4px; cursor: pointer; margin-left: 8px;">
            Later
        </button>
    `;
    
    document.body.appendChild(notification);
    
    // Auto-hide after 10 seconds
    setTimeout(() => {
        if (notification.parentElement) {
            notification.remove();
        }
    }, 10000);
}

// Monitor online/offline status
window.addEventListener('online', () => {
    updateNetworkStatus('online');
    announceToScreenReader('Internet connection restored');
});

window.addEventListener('offline', () => {
    const hasServiceWorker = 'serviceWorker' in navigator;
    updateNetworkStatus(hasServiceWorker ? 'offline-enhanced' : 'offline-basic');
    announceToScreenReader('Working offline');
});

// Make functions globally available for onclick handlers
window.showTab = showTab;
window.editRequest = editRequest;
window.deleteRequest = deleteRequest;
window.selectRequest = selectRequest;
window.sortTable = sortTable;