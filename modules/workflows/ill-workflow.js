// assets/js/modules/ill-workflow.js
// SilentStacks v2.0 - Complete ILL Workflow Implementation
// Handles the complete ILL (Interlibrary Loan) process automation

(() => {
  'use strict';

  class ILLWorkflow {
    constructor() {
      this.initialized = false;
      this.activeWorkflows = new Map();
      this.emailTemplates = this.initializeTemplates();
      this.workflowSteps = [
        'request-created',
        'docline-submitted',
        'library-contacted', 
        'follow-up-sent',
        'response-received',
        'patron-notified',
        'request-completed'
      ];
      this.followUpSchedule = new Map(); // requestId -> timeout
    }

    // Initialize email templates
    initializeTemplates() {
      return {
        orderPlaced: {
          subject: 'ILL Order Placed - {title}',
          body: `Dear Patron,

Your interlibrary loan request has been placed with DOCLINE.

Article: {title}
Authors: {authors}  
Journal: {journal}
DOCLINE Number: {doclineNumber}
Date Ordered: {dateOrdered}
Request ID: {requestId}

Expected delivery: 7-10 business days
You will receive updates as the request progresses.

{librarianName}
{libraryName}
{contactInfo}`
        },

        followUpRequired: {
          subject: 'ILL Follow-up Required - {title}',
          body: `INTERNAL FOLLOW-UP ALERT

Request ID: {requestId}
DOCLINE Number: {doclineNumber}
Days Since Submission: {daysSinceSubmission}
Last Status Check: {lastStatusCheck}

Recommended Actions:
- Check DOCLINE status
- Contact lending library if needed
- Update patron if delayed

Auto-generated by SilentStacks ILL Workflow
{timestamp}`
        },

        statusUpdate: {
          subject: 'ILL Status Update - {title}',
          body: `Dear Patron,

Update on your interlibrary loan request:

Request ID: {requestId}
DOCLINE Number: {doclineNumber}
Current Status: {currentStatus}
Update Date: {updateDate}

{statusDetails}

Next Steps: {nextSteps}
Expected Timeline: {expectedTimeline}

{librarianName}
{libraryName}
{contactInfo}`
        },

        requestComplete: {
          subject: 'ILL Request Completed - {title}',
          body: `Dear Patron,

Your interlibrary loan request has been completed.

Article: {title}
Delivery Method: {deliveryMethod}
Access Information: {accessInfo}
Completion Date: {completionDate}

{completionNotes}

Thank you for using our interlibrary loan service.

{librarianName}
{libraryName}
{contactInfo}`
        }
      };
    }

    // Main initialization
    async initialize() {
      if (this.initialized) return;

      console.log('🏥 Initializing ILL Workflow System...');
      
      try {
        await this.setupUI();
        await this.setupEventListeners();
        await this.restoreActiveWorkflows();
        
        this.initialized = true;
        console.log('✅ ILL Workflow System initialized');
        
        return { status: 'success', module: 'ILLWorkflow' };
      } catch (error) {
        console.error('❌ Failed to initialize ILL Workflow:', error);
        return { status: 'error', module: 'ILLWorkflow', error: error.message };
      }
    }

    // Setup UI elements for ILL workflow
    async setupUI() {
      this.addWorkflowStyles();
      this.addWorkflowButtons();
      this.createWorkflowPanel();
    }

    // Add CSS styles
    addWorkflowStyles() {
      if (document.getElementById('ill-workflow-styles')) return;

      const style = document.createElement('style');
      style.id = 'ill-workflow-styles';
      style.textContent = `
        .ill-workflow-btn {
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          color: white;
          border: none;
          padding: 8px 16px;
          border-radius: 6px;
          font-size: 12px;
          cursor: pointer;
          margin: 2px;
          transition: all 0.2s ease;
        }

        .ill-workflow-btn:hover {
          transform: translateY(-1px);
          box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        }

        .ill-workflow-btn.step-complete {
          background: linear-gradient(135deg, #4CAF50, #45a049);
        }

        .ill-workflow-btn.step-pending {
          background: linear-gradient(135deg, #ff9800, #f57c00);
        }

        .ill-workflow-panel {
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: white;
          border-radius: 12px;
          box-shadow: 0 20px 40px rgba(0,0,0,0.15);
          padding: 24px;
          width: 90%;
          max-width: 600px;
          max-height: 80vh;
          overflow-y: auto;
          z-index: 10001;
          display: none;
        }

        .ill-workflow-overlay {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0,0,0,0.5);
          z-index: 10000;
          display: none;
        }

        .ill-progress-bar {
          background: #e0e0e0;
          border-radius: 10px;
          height: 8px;
          margin: 16px 0;
          overflow: hidden;
        }

        .ill-progress-fill {
          background: linear-gradient(90deg, #667eea, #764ba2);
          height: 100%;
          border-radius: 10px;
          transition: width 0.3s ease;
        }

        .ill-step {
          display: flex;
          align-items: center;
          padding: 12px;
          border-radius: 8px;
          margin: 8px 0;
          border-left: 4px solid #e0e0e0;
        }

        .ill-step.completed {
          background: #f1f8e9;
          border-left-color: #4CAF50;
        }

        .ill-step.active {
          background: #fff3e0;
          border-left-color: #ff9800;
        }

        .ill-step.pending {
          background: #fafafa;
          border-left-color: #e0e0e0;
        }

        .ill-step-icon {
          width: 24px;
          height: 24px;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          margin-right: 12px;
          font-weight: bold;
          font-size: 12px;
        }

        .ill-step.completed .ill-step-icon {
          background: #4CAF50;
          color: white;
        }

        .ill-step.active .ill-step-icon {
          background: #ff9800;
          color: white;
        }

        .ill-step.pending .ill-step-icon {
          background: #e0e0e0;
          color: #666;
        }
      `;
      
      document.head.appendChild(style);
    }

    // Add workflow buttons to request cards
    addWorkflowButtons() {
      // Add to existing request cards
      const observer = new MutationObserver(() => {
        document.querySelectorAll('.request-card').forEach(card => {
          if (!card.querySelector('.ill-workflow-btn')) {
            this.addButtonToCard(card);
          }
        });
      });

      observer.observe(document.body, { childList: true, subtree: true });
      
      // Add to existing cards
      document.querySelectorAll('.request-card').forEach(card => {
        this.addButtonToCard(card);
      });
    }

    // Add ILL button to a specific card
    addButtonToCard(card) {
      const requestId = card.dataset.requestId;
      if (!requestId) return;

      const buttonContainer = card.querySelector('.card-actions') || card;
      
      const illBtn = document.createElement('button');
      illBtn.className = 'ill-workflow-btn';
      illBtn.innerHTML = '🏥 ILL';
      illBtn.title = 'Manage ILL Workflow';
      
      illBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        this.openWorkflowPanel(requestId);
      });

      buttonContainer.appendChild(illBtn);
    }

    // Create the workflow management panel
    createWorkflowPanel() {
      // Overlay
      const overlay = document.createElement('div');
      overlay.className = 'ill-workflow-overlay';
      overlay.addEventListener('click', () => this.closeWorkflowPanel());
      
      // Panel
      const panel = document.createElement('div');
      panel.className = 'ill-workflow-panel';
      panel.innerHTML = `
        <div class="ill-panel-header">
          <h3>ILL Workflow Management</h3>
          <button class="close-btn" style="float: right;">&times;</button>
        </div>
        <div class="ill-panel-content">
          <!-- Dynamic content -->
        </div>
      `;

      panel.querySelector('.close-btn').addEventListener('click', () => this.closeWorkflowPanel());

      document.body.appendChild(overlay);
      document.body.appendChild(panel);
    }

    // Open workflow panel for a specific request
    openWorkflowPanel(requestId) {
      const request = this.getRequest(requestId);
      if (!request) {
        console.error('Request not found:', requestId);
        return;
      }

      const panel = document.querySelector('.ill-workflow-panel');
      const overlay = document.querySelector('.ill-workflow-overlay');
      const content = panel.querySelector('.ill-panel-content');

      // Get workflow status
      const workflow = this.activeWorkflows.get(requestId) || this.createWorkflow(requestId);
      
      content.innerHTML = this.generateWorkflowHTML(request, workflow);
      this.attachWorkflowHandlers(requestId, content);

      overlay.style.display = 'block';
      panel.style.display = 'block';
    }

    // Generate HTML for workflow panel
    generateWorkflowHTML(request, workflow) {
      const progress = Math.round((workflow.currentStepIndex / (this.workflowSteps.length - 1)) * 100);
      
      return `
        <div class="ill-request-info">
          <h4>${request.title}</h4>
          <p><strong>Request ID:</strong> ${request.id}</p>
          <p><strong>DOCLINE:</strong> ${request.docline || 'Not assigned'}</p>
          <p><strong>Status:</strong> ${request.status}</p>
        </div>

        <div class="ill-progress-section">
          <h4>Workflow Progress</h4>
          <div class="ill-progress-bar">
            <div class="ill-progress-fill" style="width: ${progress}%"></div>
          </div>
          <small>${progress}% complete</small>
        </div>

        <div class="ill-steps-section">
          <h4>Workflow Steps</h4>
          ${this.generateStepsHTML(workflow)}
        </div>

        <div class="ill-actions-section">
          <h4>Quick Actions</h4>
          <button class="ill-action-btn" data-action="submit-docline">Submit to DOCLINE</button>
          <button class="ill-action-btn" data-action="send-followup">Send Follow-up</button>
          <button class="ill-action-btn" data-action="update-status">Update Status</button>
          <button class="ill-action-btn" data-action="notify-patron">Notify Patron</button>
          <button class="ill-action-btn" data-action="complete-request">Complete Request</button>
        </div>

        <div class="ill-notes-section">
          <h4>Workflow Notes</h4>
          <textarea id="workflow-notes" rows="3" style="width: 100%; margin-bottom: 8px;">${workflow.notes || ''}</textarea>
          <button class="ill-action-btn" data-action="save-notes">Save Notes</button>
        </div>
      `;
    }

    // Generate HTML for workflow steps
    generateStepsHTML(workflow) {
      return this.workflowSteps.map((step, index) => {
        let status = 'pending';
        if (index < workflow.currentStepIndex) status = 'completed';
        else if (index === workflow.currentStepIndex) status = 'active';

        const stepData = workflow.steps[step] || {};
        
        return `
          <div class="ill-step ${status}">
            <div class="ill-step-icon">${status === 'completed' ? '✓' : index + 1}</div>
            <div class="ill-step-content">
              <div class="ill-step-title">${this.getStepTitle(step)}</div>
              <div class="ill-step-details">
                ${stepData.completedAt ? `Completed: ${new Date(stepData.completedAt).toLocaleDateString()}` : ''}
                ${stepData.notes ? `<br><small>${stepData.notes}</small>` : ''}
              </div>
            </div>
            ${status === 'active' ? `<button class="ill-complete-step" data-step="${step}">Complete</button>` : ''}
          </div>
        `;
      }).join('');
    }

    // Get human-readable step title
    getStepTitle(step) {
      const titles = {
        'request-created': 'Request Created',
        'docline-submitted': 'Submitted to DOCLINE', 
        'library-contacted': 'Library Contacted',
        'follow-up-sent': 'Follow-up Sent',
        'response-received': 'Response Received',
        'patron-notified': 'Patron Notified',
        'request-completed': 'Request Completed'
      };
      return titles[step] || step;
    }

    // Attach event handlers to workflow panel
    attachWorkflowHandlers(requestId, content) {
      // Action buttons
      content.querySelectorAll('.ill-action-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const action = e.target.dataset.action;
          this.handleWorkflowAction(requestId, action);
        });
      });

      // Complete step buttons
      content.querySelectorAll('.ill-complete-step').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const step = e.target.dataset.step;
          this.completeWorkflowStep(requestId, step);
        });
      });
    }

    // Handle workflow actions
    async handleWorkflowAction(requestId, action) {
      const request = this.getRequest(requestId);
      const workflow = this.activeWorkflows.get(requestId);

      switch (action) {
        case 'submit-docline':
          await this.submitToDocline(requestId);
          break;
        case 'send-followup':
          await this.sendFollowUp(requestId);
          break;
        case 'update-status':
          await this.updateRequestStatus(requestId);
          break;
        case 'notify-patron':
          await this.notifyPatron(requestId);
          break;
        case 'complete-request':
          await this.completeRequest(requestId);
          break;
        case 'save-notes':
          const notes = document.getElementById('workflow-notes').value;
          await this.saveWorkflowNotes(requestId, notes);
          break;
      }

      // Refresh panel
      this.openWorkflowPanel(requestId);
    }

    // Complete a workflow step
    async completeWorkflowStep(requestId, step) {
      const workflow = this.activeWorkflows.get(requestId);
      if (!workflow) return;

      const stepIndex = this.workflowSteps.indexOf(step);
      if (stepIndex === -1) return;

      // Mark step as completed
      workflow.steps[step] = {
        completedAt: new Date().toISOString(),
        completedBy: 'Librarian', // TODO: Get from user session
        notes: workflow.steps[step]?.notes || ''
      };

      // Advance to next step
      workflow.currentStepIndex = Math.max(workflow.currentStepIndex, stepIndex + 1);
      workflow.lastModified = new Date().toISOString();

      // Save workflow
      this.saveWorkflow(requestId, workflow);

      // Trigger any automated actions for the completed step
      await this.triggerStepActions(requestId, step);

      console.log(`✅ Completed workflow step: ${step} for request ${requestId}`);
    }

    // Close workflow panel
    closeWorkflowPanel() {
      const panel = document.querySelector('.ill-workflow-panel');
      const overlay = document.querySelector('.ill-workflow-overlay');
      
      panel.style.display = 'none';
      overlay.style.display = 'none';
    }

    // Create new workflow for a request
    createWorkflow(requestId) {
      const workflow = {
        requestId,
        currentStepIndex: 0,
        steps: {},
        notes: '',
        createdAt: new Date().toISOString(),
        lastModified: new Date().toISOString()
      };

      this.activeWorkflows.set(requestId, workflow);
      this.saveWorkflow(requestId, workflow);
      
      return workflow;
    }

    // Get request data (placeholder - integrate with actual data manager)
    getRequest(requestId) {
      // TODO: Integrate with actual data manager
      return window.SilentStacks?.modules?.DataManager?.getRequest?.(requestId) || {
        id: requestId,
        title: 'Sample Request',
        status: 'pending',
        docline: ''
      };
    }

    // Save workflow to localStorage
    saveWorkflow(requestId, workflow) {
      try {
        const workflows = JSON.parse(localStorage.getItem('silentstacks_workflows') || '{}');
        workflows[requestId] = workflow;
        localStorage.setItem('silentstacks_workflows', JSON.stringify(workflows));
      } catch (error) {
        console.error('Failed to save workflow:', error);
      }
    }

    // Restore active workflows from localStorage
    async restoreActiveWorkflows() {
      try {
        const workflows = JSON.parse(localStorage.getItem('silentstacks_workflows') || '{}');
        Object.entries(workflows).forEach(([requestId, workflow]) => {
          this.activeWorkflows.set(requestId, workflow);
        });
        console.log(`📋 Restored ${this.activeWorkflows.size} active workflows`);
      } catch (error) {
        console.error('Failed to restore workflows:', error);
      }
    }

    // Setup event listeners
    setupEventListeners() {
      // Listen for new requests to auto-create workflows
      if (window.SilentStacks?.eventBus) {
        window.SilentStacks.eventBus.on('request:created', (data) => {
          this.createWorkflow(data.requestId);
        });
      }
    }

    // Automated workflow actions
    async triggerStepActions(requestId, step) {
      switch (step) {
        case 'request-created':
          // Schedule follow-up reminder
          this.scheduleFollowUp(requestId, 3); // 3 days
          break;
        case 'docline-submitted':
          // Schedule status check
          this.scheduleFollowUp(requestId, 7); // 7 days
          break;
        case 'response-received':
          // Auto-notify patron of update
          await this.generatePatronNotification(requestId);
          break;
      }
    }

    // Submit request to DOCLINE
    async submitToDocline(requestId) {
      const request = this.getRequest(requestId);
      const doclineNumber = this.generateDoclineNumber();
      
      // Update request with DOCLINE number
      if (window.SilentStacks?.modules?.DataManager?.updateRequest) {
        const updatedRequest = { ...request, docline: doclineNumber };
        window.SilentStacks.modules.DataManager.updateRequest(requestId, updatedRequest);
      }

      // Complete the docline-submitted step
      await this.completeWorkflowStep(requestId, 'docline-submitted');

      // Generate confirmation email
      const email = this.generateEmail('orderPlaced', {
        ...request,
        doclineNumber,
        dateOrdered: new Date().toLocaleDateString(),
        librarianName: 'Library Staff',
        libraryName: 'Medical Library',
        contactInfo: 'library@institution.edu'
      });

      this.showNotification(`DOCLINE submission completed for ${request.title}`, 'success');
      console.log('📧 Generated email:', email);
      
      return { success: true, doclineNumber };
    }

    // Send follow-up communication
    async sendFollowUp(requestId) {
      const request = this.getRequest(requestId);
      const workflow = this.activeWorkflows.get(requestId);
      
      const daysSinceSubmission = workflow?.steps['docline-submitted'] ? 
        Math.floor((Date.now() - new Date(workflow.steps['docline-submitted'].completedAt)) / (1000 * 60 * 60 * 24)) : 0;

      const email = this.generateEmail('followUpRequired', {
        ...request,
        daysSinceSubmission,
        lastStatusCheck: workflow?.lastStatusCheck || 'Never',
        timestamp: new Date().toISOString()
      });

      // Complete follow-up step
      await this.completeWorkflowStep(requestId, 'follow-up-sent');

      this.showNotification(`Follow-up sent for ${request.title}`, 'info');
      console.log('📧 Generated follow-up:', email);
      
      return { success: true, email };
    }

    // Update request status
    async updateRequestStatus(requestId) {
      const request = this.getRequest(requestId);
      
      // Show status update dialog
      const newStatus = prompt('Enter new status:', request.status);
      if (!newStatus) return;

      // Update request
      if (window.SilentStacks?.modules?.DataManager?.updateRequest) {
        const updatedRequest = { ...request, status: newStatus };
        window.SilentStacks.modules.DataManager.updateRequest(requestId, updatedRequest);
      }

      // Complete response-received step if appropriate
      if (newStatus.includes('received') || newStatus.includes('available')) {
        await this.completeWorkflowStep(requestId, 'response-received');
      }

      this.showNotification(`Status updated to: ${newStatus}`, 'success');
      
      return { success: true, newStatus };
    }

    // Notify patron of updates
    async notifyPatron(requestId) {
      const request = this.getRequest(requestId);
      
      const email = this.generateEmail('statusUpdate', {
        ...request,
        currentStatus: request.status,
        updateDate: new Date().toLocaleDateString(),
        statusDetails: 'Your request has been processed.',
        nextSteps: 'We will notify you when the article is available.',
        expectedTimeline: '2-3 business days',
        librarianName: 'Library Staff',
        libraryName: 'Medical Library',
        contactInfo: 'library@institution.edu'
      });

      // Complete patron notification step
      await this.completeWorkflowStep(requestId, 'patron-notified');

      this.showNotification(`Patron notification sent for ${request.title}`, 'success');
      console.log('📧 Patron notification:', email);
      
      return { success: true, email };
    }

    // Complete the entire request
    async completeRequest(requestId) {
      const request = this.getRequest(requestId);
      
      // Update request status to completed
      if (window.SilentStacks?.modules?.DataManager?.updateRequest) {
        const updatedRequest = { 
          ...request, 
          status: 'completed',
          completedAt: new Date().toISOString()
        };
        window.SilentStacks.modules.DataManager.updateRequest(requestId, updatedRequest);
      }

      // Complete final workflow step
      await this.completeWorkflowStep(requestId, 'request-completed');

      // Generate completion email
      const email = this.generateEmail('requestComplete', {
        ...request,
        deliveryMethod: 'Electronic delivery',
        accessInfo: 'Check your email for the PDF',
        completionDate: new Date().toLocaleDateString(),
        completionNotes: 'Request fulfilled successfully.',
        librarianName: 'Library Staff',
        libraryName: 'Medical Library',
        contactInfo: 'library@institution.edu'
      });

      // Clear follow-up reminders
      this.clearFollowUp(requestId);

      this.showNotification(`Request completed: ${request.title}`, 'success');
      console.log('📧 Completion email:', email);
      
      return { success: true, email };
    }

    // Save workflow notes
    async saveWorkflowNotes(requestId, notes) {
      const workflow = this.activeWorkflows.get(requestId);
      if (workflow) {
        workflow.notes = notes;
        workflow.lastModified = new Date().toISOString();
        this.saveWorkflow(requestId, workflow);
        this.showNotification('Notes saved', 'success');
      }
    }

    // Generate DOCLINE number (placeholder)
    generateDoclineNumber() {
      return `DOC${Date.now().toString().slice(-8)}`;
    }

    // Generate email from template
    generateEmail(templateName, data) {
      const template = this.emailTemplates[templateName];
      if (!template) return null;

      let subject = template.subject;
      let body = template.body;

      // Replace placeholders
      Object.entries(data).forEach(([key, value]) => {
        const placeholder = `{${key}}`;
        subject = subject.replace(new RegExp(placeholder, 'g'), value || '');
        body = body.replace(new RegExp(placeholder, 'g'), value || '');
      });

      return { subject, body, timestamp: new Date().toISOString() };
    }

    // Schedule follow-up reminder
    scheduleFollowUp(requestId, days) {
      // Clear existing reminder
      this.clearFollowUp(requestId);

      // Set new reminder
      const timeout = setTimeout(() => {
        this.triggerFollowUpReminder(requestId);
      }, days * 24 * 60 * 60 * 1000); // Convert days to milliseconds

      this.followUpSchedule.set(requestId, timeout);
      console.log(`📅 Scheduled follow-up for request ${requestId} in ${days} days`);
    }

    // Clear follow-up reminder
    clearFollowUp(requestId) {
      const timeout = this.followUpSchedule.get(requestId);
      if (timeout) {
        clearTimeout(timeout);
        this.followUpSchedule.delete(requestId);
        console.log(`❌ Cleared follow-up reminder for request ${requestId}`);
      }
    }

    // Trigger follow-up reminder
    triggerFollowUpReminder(requestId) {
      const request = this.getRequest(requestId);
      if (!request) return;

      this.showNotification(`Follow-up reminder: ${request.title}`, 'warning');
      
      // Auto-generate follow-up email
      this.sendFollowUp(requestId);
    }

    // Generate patron notification
    async generatePatronNotification(requestId) {
      const request = this.getRequest(requestId);
      
      const email = this.generateEmail('statusUpdate', {
        ...request,
        currentStatus: request.status,
        updateDate: new Date().toLocaleDateString(),
        statusDetails: 'There has been an update to your request.',
        nextSteps: 'Please check your email for details.',
        expectedTimeline: 'Updates will continue as available',
        librarianName: 'Library Staff',
        libraryName: 'Medical Library',
        contactInfo: 'library@institution.edu'
      });

      this.showNotification(`Auto-notification generated for ${request.title}`, 'info');
      console.log('📧 Auto-generated notification:', email);
    }

    // Show notification (integrate with existing notification system)
    showNotification(message, type = 'info') {
      if (window.SilentStacks?.modules?.UIController?.setStatus) {
        window.SilentStacks.modules.UIController.setStatus(message, type);
      } else {
        console.log(`[${type.toUpperCase()}] ${message}`);
      }
    }

    // Get health status for diagnostics
    getHealthStatus() {
      return {
        name: 'ILLWorkflow',
        status: this.initialized ? 'healthy' : 'not-initialized',
        activeWorkflows: this.activeWorkflows.size,
        followUpReminders: this.followUpSchedule.size,
        lastActivity: new Date().toISOString(),
        errors: [],
        performance: {
          averageProcessingTime: '< 1s',
          emailGenerationTime: '< 100ms'
        }
      };
    }

    // Public API methods
    getWorkflowStatus(requestId) {
      return this.activeWorkflows.get(requestId);
    }

    getAllActiveWorkflows() {
      return Array.from(this.activeWorkflows.entries()).map(([id, workflow]) => ({
        requestId: id,
        ...workflow
      }));
    }

    exportWorkflowData() {
      return {
        activeWorkflows: this.getAllActiveWorkflows(),
        templates: this.emailTemplates,
        stats: {
          totalWorkflows: this.activeWorkflows.size,
          pendingFollowUps: this.followUpSchedule.size
        }
      };
    }
  }

  // Create and register the module
  const illWorkflow = new ILLWorkflow();

  // Register with SilentStacks
  if (window.SilentStacks?.registerModule) {
    window.SilentStacks.registerModule('ILLWorkflow', illWorkflow);
  } else {
    window.SilentStacks = window.SilentStacks || { modules: {} };
    window.SilentStacks.modules.ILLWorkflow = illWorkflow;
  }

  console.log('🏥 ILL Workflow module loaded and registered');

})();