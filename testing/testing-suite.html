<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SilentStacks Stress Testing Suite</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        h1 { color: #2c3e50; text-align: center; }
        h2 { color: #34495e; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
        .test-section {
            margin: 30px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: #fafafa;
        }
        .test-controls {
            display: flex;
            gap: 15px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        .btn-primary { background: #3498db; color: white; }
        .btn-primary:hover { background: #2980b9; transform: translateY(-1px); }
        .btn-success { background: #27ae60; color: white; }
        .btn-success:hover { background: #229954; transform: translateY(-1px); }
        .btn-danger { background: #e74c3c; color: white; }
        .btn-danger:hover { background: #c0392b; transform: translateY(-1px); }
        .btn-warning { background: #f39c12; color: white; }
        .btn-warning:hover { background: #d68910; transform: translateY(-1px); }
        .progress-container {
            margin: 15px 0;
            background: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
        }
        .progress-bar {
            height: 20px;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
        }
        .results {
            margin-top: 20px;
            padding: 15px;
            background: #ecf0f1;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            max-height: 300px;
            overflow-y: auto;
        }
        .metric {
            display: inline-block;
            margin: 5px 10px;
            padding: 8px 15px;
            background: #34495e;
            color: white;
            border-radius: 20px;
            font-size: 14px;
        }
        .metric.good { background: #27ae60; }
        .metric.warning { background: #f39c12; }
        .metric.danger { background: #e74c3c; }
        .test-data-preview {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            margin: 10px 0;
        }
        .performance-monitor {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 10000;
            min-width: 200px;
        }
        .monitor-metric {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        .status-pass { background: #27ae60; }
        .status-fail { background: #e74c3c; }
        .status-warning { background: #f39c12; }
        .status-running { background: #3498db; animation: pulse 1s infinite; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <!-- Performance Monitor -->
    <div class="performance-monitor" id="performance-monitor">
        <h4 style="margin: 0 0 10px 0;">Live Performance</h4>
        <div class="monitor-metric">
            <span>Memory:</span>
            <span id="memory-usage">0 MB</span>
        </div>
        <div class="monitor-metric">
            <span>DOM Nodes:</span>
            <span id="dom-nodes">0</span>
        </div>
        <div class="monitor-metric">
            <span>FPS:</span>
            <span id="fps">60</span>
        </div>
        <div class="monitor-metric">
            <span>Load Time:</span>
            <span id="load-time">0ms</span>
        </div>
    </div>

    <div class="container">
        <h1>üß™ SilentStacks Massive Stress Testing Suite</h1>
        <p style="text-align: center; color: #7f8c8d; font-size: 18px;">
            Comprehensive testing for 1000+ citations, performance benchmarks, and accessibility validation
        </p>

        <!-- Test Overview -->
        <div class="test-section">
            <h2>üìä Test Overview & Metrics</h2>
            <div id="test-metrics">
                <span class="metric" id="total-tests">Tests: 0/12</span>
                <span class="metric" id="passed-tests">Passed: 0</span>
                <span class="metric" id="failed-tests">Failed: 0</span>
                <span class="metric" id="runtime">Runtime: 0s</span>
            </div>
            <div class="test-controls">
                <button class="btn btn-success" onclick="runAllTests()">üöÄ Run All Tests</button>
                <button class="btn btn-warning" onclick="generateTestData()">üìã Generate Test Data</button>
                <button class="btn btn-danger" onclick="clearAllData()">üßπ Clear All Data</button>
                <button class="btn btn-primary" onclick="exportResults()">üìÑ Export Results</button>
            </div>
            <div class="progress-container">
                <div class="progress-bar" id="main-progress" style="width: 0%">Ready to Start</div>
            </div>
        </div>

        <!-- Test Grid -->
        <div class="test-grid">
            
            <!-- Massive Dataset Tests -->
            <div class="test-section">
                <h3>üíæ Massive Dataset Tests</h3>
                <div class="test-controls">
                    <button class="btn btn-primary" onclick="runMassiveImportTest()">1000 CSV Import</button>
                    <button class="btn btn-primary" onclick="runMassiveJSONTest()">1000 JSON Import</button>
                    <button class="btn btn-primary" onclick="runMixedIdentifierTest()">Mixed ID Test</button>
                </div>
                <div id="massive-results" class="results">
                    <div>üí° Tests will import 1000 citations with mixed PMIDs/DOIs</div>
                    <div>üìà Monitors: Memory usage, DOM performance, import speed</div>
                    <div>‚ö° Thresholds: &lt;10s import, &lt;500MB memory, responsive UI</div>
                </div>
            </div>

            <!-- Performance Benchmarks -->
            <div class="test-section">
                <h3>‚ö° Performance Benchmarks</h3>
                <div class="test-controls">
                    <button class="btn btn-primary" onclick="runLoadTimeTest()">Load Time</button>
                    <button class="btn btn-primary" onclick="runSearchPerformanceTest()">Search Speed</button>
                    <button class="btn btn-primary" onclick="runRenderPerformanceTest()">Render Speed</button>
                </div>
                <div id="performance-results" class="results">
                    <div>üéØ Target: &lt;3s load time for 500 requests</div>
                    <div>üîç Target: &lt;500ms search response</div>
                    <div>üñºÔ∏è Target: &lt;2s render time for 200 items</div>
                </div>
            </div>

            <!-- API Stress Tests -->
            <div class="test-section">
                <h3>üåê API Integration Stress</h3>
                <div class="test-controls">
                    <button class="btn btn-primary" onclick="runAPIStressTest()">Rapid API Calls</button>
                    <button class="btn btn-primary" onclick="runOfflineQueueTest()">Offline Queue</button>
                    <button class="btn btn-primary" onclick="runRateLimitTest()">Rate Limiting</button>
                </div>
                <div id="api-results" class="results">
                    <div>üöÄ Testing 50 concurrent API calls</div>
                    <div>üì¥ Testing offline queue management</div>
                    <div>‚è±Ô∏è Verifying rate limit compliance</div>
                </div>
            </div>

            <!-- Browser Compatibility -->
            <div class="test-section">
                <h3>üåç Cross-Browser Tests</h3>
                <div class="test-controls">
                    <button class="btn btn-primary" onclick="runBrowserCompatTest()">Core Features</button>
                    <button class="btn btn-primary" onclick="runLocalStorageTest()">Storage Limits</button>
                    <button class="btn btn-primary" onclick="runCSSCompatTest()">CSS Features</button>
                </div>
                <div id="browser-results" class="results">
                    <div>üèÉ Browser: <span id="browser-info">Detecting...</span></div>
                    <div>üíæ Local Storage: <span id="storage-info">Testing...</span></div>
                    <div>üé® CSS Grid Support: <span id="css-info">Testing...</span></div>
                </div>
            </div>

            <!-- Mobile Responsiveness -->
            <div class="test-section">
                <h3>üì± Mobile & Responsive</h3>
                <div class="test-controls">
                    <button class="btn btn-primary" onclick="runResponsiveTest()">Layout Test</button>
                    <button class="btn btn-primary" onclick="runTouchTargetTest()">Touch Targets</button>
                    <button class="btn btn-primary" onclick="runViewportTest()">Viewport Test</button>
                </div>
                <div id="mobile-results" class="results">
                    <div>üì± Viewport: <span id="viewport-info">Getting...</span></div>
                    <div>üëÜ Touch targets: Minimum 44px check</div>
                    <div>üîÑ Orientation: Testing landscape/portrait</div>
                </div>
            </div>

            <!-- Accessibility (AAA) -->
            <div class="test-section">
                <h3>‚ôø Accessibility (WCAG AAA)</h3>
                <div class="test-controls">
                    <button class="btn btn-primary" onclick="runA11yTest()">Full A11y Audit</button>
                    <button class="btn btn-primary" onclick="runKeyboardTest()">Keyboard Nav</button>
                    <button class="btn btn-primary" onclick="runContrastTest()">Color Contrast</button>
                </div>
                <div id="a11y-results" class="results">
                    <div>‚å®Ô∏è Keyboard navigation test</div>
                    <div>üé® Color contrast ratio validation</div>
                    <div>üîä Screen reader compatibility</div>
                </div>
            </div>

        </div>

        <!-- Test Data Preview -->
        <div class="test-section">
            <h2>üìã Generated Test Data Preview</h2>
            <div class="test-controls">
                <button class="btn btn-primary" onclick="showSampleCSV()">Sample CSV (50 rows)</button>
                <button class="btn btn-primary" onclick="showSampleJSON()">Sample JSON (50 rows)</button>
                <button class="btn btn-primary" onclick="showMixedData()">Mixed Identifiers</button>
            </div>
            <div class="test-data-preview" id="test-data-preview">
                Click "Generate Test Data" to see sample data for testing...
            </div>
        </div>

        <!-- Detailed Results -->
        <div class="test-section">
            <h2>üìà Detailed Test Results</h2>
            <div id="detailed-results" class="results" style="max-height: 500px;">
                Test results will appear here...
            </div>
        </div>

    </div>

    <script>
        // Global test state
        let testState = {
            totalTests: 12,
            passedTests: 0,
            failedTests: 0,
            startTime: null,
            testData: [],
            performanceMetrics: {}
        };

        // Performance monitoring
        let performanceInterval;
        let frameCount = 0;
        let lastFrameTime = performance.now();

        // Initialize performance monitoring
        function initPerformanceMonitoring() {
            updateBrowserInfo();
            startFPSMonitoring();
            
            performanceInterval = setInterval(() => {
                updateMemoryUsage();
                updateDOMNodes();
                updateLoadTime();
            }, 1000);
        }

        function updateBrowserInfo() {
            const browserInfo = navigator.userAgent.split(' ').slice(-2).join(' ');
            document.getElementById('browser-info').textContent = browserInfo;
            
            // Test viewport
            const viewport = `${window.innerWidth}x${window.innerHeight}`;
            document.getElementById('viewport-info').textContent = viewport;
            
            // Test local storage
            try {
                localStorage.setItem('test', 'test');
                localStorage.removeItem('test');
                document.getElementById('storage-info').textContent = 'Available';
            } catch(e) {
                document.getElementById('storage-info').textContent = 'Limited/Unavailable';
            }
            
            // Test CSS Grid
            const testEl = document.createElement('div');
            testEl.style.display = 'grid';
            const hasGrid = testEl.style.display === 'grid';
            document.getElementById('css-info').textContent = hasGrid ? 'Supported' : 'Not Supported';
        }

        function updateMemoryUsage() {
            if (performance.memory) {
                const used = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                document.getElementById('memory-usage').textContent = `${used} MB`;
                
                // Warning if over 200MB
                const memoryEl = document.getElementById('memory-usage');
                if (used > 200) {
                    memoryEl.style.color = '#e74c3c';
                } else if (used > 100) {
                    memoryEl.style.color = '#f39c12';
                } else {
                    memoryEl.style.color = '#27ae60';
                }
            }
        }

        function updateDOMNodes() {
            const nodeCount = document.getElementsByTagName('*').length;
            document.getElementById('dom-nodes').textContent = nodeCount;
        }

        function updateLoadTime() {
            if (performance.timing) {
                const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;
                document.getElementById('load-time').textContent = `${loadTime}ms`;
            }
        }

        function startFPSMonitoring() {
            function countFrame() {
                frameCount++;
                requestAnimationFrame(countFrame);
            }
            
            requestAnimationFrame(countFrame);
            
            setInterval(() => {
                const fps = Math.round(frameCount);
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                
                // Color code FPS
                const fpsEl = document.getElementById('fps');
                if (fps < 30) {
                    fpsEl.style.color = '#e74c3c';
                } else if (fps < 50) {
                    fpsEl.style.color = '#f39c12';
                } else {
                    fpsEl.style.color = '#27ae60';
                }
            }, 1000);
        }

        // Test Data Generation
        function generateTestData() {
            log('üìã Generating massive test dataset...');
            
            const pmids = [
                "34534243", "33479320", "32895479", "31676865", "30940615",
                "34123456", "33789012", "32456789", "31234567", "30987654"
            ];
            
            const dois = [
                "10.1038/s41586-021-03819-2", "10.1126/science.abg1919",
                "10.1016/j.cell.2021.02.032", "10.1038/s41591-021-01377-8",
                "10.1056/NEJMoa2034577", "10.1001/jama.2021.5469"
            ];
            
            const journals = [
                "Nature", "Science", "Cell", "Nature Medicine", "New England Journal of Medicine",
                "JAMA", "The Lancet", "Nature Biotechnology", "Nature Genetics", "Cell Metabolism"
            ];
            
            const authors = [
                "Smith JA, Johnson BD, Williams CL",
                "Brown DE, Davis EF, Miller FG",
                "Wilson GH, Moore HI, Taylor IJ",
                "Anderson JK, Thomas KL, Jackson LM"
            ];
            
            const titles = [
                "Novel therapeutic approaches in precision medicine",
                "CRISPR-Cas9 gene editing advances in clinical trials",
                "Machine learning applications in drug discovery",
                "Immunotherapy breakthroughs in cancer treatment",
                "Biomarker identification for personalized therapy"
            ];

            testState.testData = [];
            
            // Generate 1000 test records
            for (let i = 0; i < 1000; i++) {
                const record = {
                    pmid: Math.random() > 0.5 ? pmids[Math.floor(Math.random() * pmids.length)] : '',
                    doi: Math.random() > 0.5 ? dois[Math.floor(Math.random() * dois.length)] : '',
                    title: titles[Math.floor(Math.random() * titles.length)] + ` - Study ${i + 1}`,
                    authors: authors[Math.floor(Math.random() * authors.length)],
                    journal: journals[Math.floor(Math.random() * journals.length)],
                    year: 2018 + Math.floor(Math.random() * 7),
                    priority: ['normal', 'rush', 'urgent'][Math.floor(Math.random() * 3)],
                    status: ['pending', 'in-progress', 'fulfilled'][Math.floor(Math.random() * 3)],
                    tags: `tag${Math.floor(Math.random() * 10)}, category${Math.floor(Math.random() * 5)}`,
                    notes: `Test note for record ${i + 1} with additional details`
                };
                testState.testData.push(record);
            }
            
            log(`‚úÖ Generated ${testState.testData.length} test records`);
            updateProgress(10, `Generated ${testState.testData.length} test records`);
        }

        // Sample data display functions
        function showSampleCSV() {
            if (testState.testData.length === 0) {
                generateTestData();
            }
            
            const headers = ['PMID', 'DOI', 'Title', 'Authors', 'Journal', 'Year', 'Priority', 'Status', 'Tags', 'Notes'];
            let csv = headers.join(',') + '\n';
            
            for (let i = 0; i < Math.min(50, testState.testData.length); i++) {
                const record = testState.testData[i];
                const row = [
                    record.pmid, record.doi, `"${record.title}"`, `"${record.authors}"`,
                    record.journal, record.year, record.priority, record.status,
                    `"${record.tags}"`, `"${record.notes}"`
                ];
                csv += row.join(',') + '\n';
            }
            
            document.getElementById('test-data-preview').textContent = csv;
        }

        function showSampleJSON() {
            if (testState.testData.length === 0) {
                generateTestData();
            }
            
            const sample = testState.testData.slice(0, 50);
            document.getElementById('test-data-preview').textContent = JSON.stringify(sample, null, 2);
        }

        function showMixedData() {
            if (testState.testData.length === 0) {
                generateTestData();
            }
            
            const mixed = testState.testData.slice(0, 20).map((record, i) => {
                // Create mixed scenarios
                if (i % 3 === 0) {
                    return { ...record, pmid: '', doi: '' }; // Title only
                } else if (i % 3 === 1) {
                    return { ...record, doi: '' }; // PMID only
                } else {
                    return { ...record, pmid: '' }; // DOI only
                }
            });
            
            document.getElementById('test-data-preview').textContent = JSON.stringify(mixed, null, 2);
        }

        // Main test functions
        async function runAllTests() {
            log('üöÄ Starting comprehensive stress test suite...');
            testState.startTime = performance.now();
            testState.passedTests = 0;
            testState.failedTests = 0;
            
            updateProgress(0, 'Initializing tests...');
            
            try {
                // Generate test data first
                if (testState.testData.length === 0) {
                    generateTestData();
                }
                
                // Run all test categories
                await runMassiveImportTest();
                await runMassiveJSONTest();
                await runMixedIdentifierTest();
                await runLoadTimeTest();
                await runSearchPerformanceTest();
                await runRenderPerformanceTest();
                await runAPIStressTest();
                await runOfflineQueueTest();
                await runRateLimitTest();
                await runBrowserCompatTest();
                await runResponsiveTest();
                await runA11yTest();
                
                const endTime = performance.now();
                const totalTime = Math.round((endTime - testState.startTime) / 1000);
                
                updateProgress(100, `All tests completed in ${totalTime}s`);
                updateMetrics();
                
                log(`üéâ Test suite completed! ${testState.passedTests} passed, ${testState.failedTests} failed`);
                
            } catch (error) {
                log(`‚ùå Test suite failed: ${error.message}`);
                updateProgress(0, 'Test suite failed');
            }
        }

        async function runMassiveImportTest() {
            log('üíæ Running massive CSV import test (1000 records)...');
            const startTime = performance.now();
            
            try {
                // Simulate CSV import
                const csvData = convertToCSV(testState.testData);
                
                // Measure import performance
                const importStart = performance.now();
                await simulateImport(csvData, 'csv');
                const importTime = performance.now() - importStart;
                
                const success = importTime < 10000; // Less than 10 seconds
                logTestResult('Massive CSV Import', success, `${Math.round(importTime)}ms`);
                
                if (success) testState.passedTests++;
                else testState.failedTests++;
                
            } catch (error) {
                logTestResult('Massive CSV Import', false, error.message);
                testState.failedTests++;
            }
        }

        async function runMassiveJSONTest() {
            log('üíæ Running massive JSON import test (1000 records)...');
            
            try {
                const jsonData = JSON.stringify(testState.testData);
                
                const importStart = performance.now();
                await simulateImport(jsonData, 'json');
                const importTime = performance.now() - importStart;
                
                const success = importTime < 8000; // JSON should be faster
                logTestResult('Massive JSON Import', success, `${Math.round(importTime)}ms`);
                
                if (success) testState.passedTests++;
                else testState.failedTests++;
                
            } catch (error) {
                logTestResult('Massive JSON Import', false, error.message);
                testState.failedTests++;
            }
        }

        async function runMixedIdentifierTest() {
            log('üîÑ Testing mixed identifier handling...');
            
            try {
                const mixedData = testState.testData.slice(0, 100).map((record, i) => {
                    if (i % 4 === 0) return { ...record, pmid: '', doi: '' };
                    if (i % 4 === 1) return { ...record, doi: '' };
                    if (i % 4 === 2) return { ...record, pmid: '' };
                    return record;
                });
                
                const processStart = performance.now();
                const processedCount = await simulateProcessing(mixedData);
                const processTime = performance.now() - processStart;
                
                const success = processedCount >= 95 && processTime < 5000;
                logTestResult('Mixed Identifier Test', success, `${processedCount}/100 processed in ${Math.round(processTime)}ms`);
                
                if (success) testState.passedTests++;
                else testState.failedTests++;
                
            } catch (error) {
                logTestResult('Mixed Identifier Test', false, error.message);
                testState.failedTests++;
            }
        }

        async function runLoadTimeTest() {
            log('‚ö° Testing load time performance...');
            
            try {
                const loadStart = performance.now();
                
                // Simulate loading 500 requests
                await simulateDataLoad(500);
                
                const loadTime = performance.now() - loadStart;
                const success = loadTime < 3000; // Under 3 seconds
                
                logTestResult('Load Time Test', success, `${Math.round(loadTime)}ms for 500 requests`);
                
                if (success) testState.passedTests++;
                else testState.failedTests++;
                
            } catch (error) {
                logTestResult('Load Time Test', false, error.message);
                testState.failedTests++;
            }
        }

        async function runSearchPerformanceTest() {
            log('üîç Testing search performance...');
            
            try {
                const searchStart = performance.now();
                
                // Simulate search through large dataset
                await simulateSearch(testState.testData, 'cardiology');
                
                const searchTime = performance.now() - searchStart;
                const success = searchTime < 500; // Under 500ms
                
                logTestResult('Search Performance', success, `${Math.round(searchTime)}ms`);
                
                if (success) testState.passedTests++;
                else testState.failedTests++;
                
            } catch (error) {
                logTestResult('Search Performance', false, error.message);
                testState.failedTests++;
            }
        }

        async function runRenderPerformanceTest() {
            log('üñºÔ∏è Testing render performance...');
            
            try {
                const renderStart = performance.now();
                
                // Simulate rendering 200 items
                await simulateRender(200);
                
                const renderTime = performance.now() - renderStart;
                const success = renderTime < 2000; // Under 2 seconds
                
                logTestResult('Render Performance', success, `${Math.round(renderTime)}ms for 200 items`);
                
                if (success) testState.passedTests++;
                else testState.failedTests++;
                
            } catch (error) {
                logTestResult('Render Performance', false, error.message);
                testState.failedTests++;
            }
        }

        async function runAPIStressTest() {
            log('üåê Testing API stress handling...');
            
            try {
                const apiStart = performance.now();
                
                // Simulate 50 concurrent API calls
                const promises = [];
                for (let i = 0; i < 50; i++) {
                    promises.push(simulateAPICall());
                }
                
                const results = await Promise.allSettled(promises);
                const apiTime = performance.now() - apiStart;
                
                const successCount = results.filter(r => r.status === 'fulfilled').length;
                const success = successCount >= 45 && apiTime < 30000; // 90% success rate, under 30s
                
                logTestResult('API Stress Test', success, `${successCount}/50 successful in ${Math.round(apiTime)}ms`);
                
                if (success) testState.passedTests++;
                else testState.failedTests++;
                
            } catch (error) {
                logTestResult('API Stress Test', false, error.message);
                testState.failedTests++;
            }
        }

        async function runOfflineQueueTest() {
            log('üì¥ Testing offline queue management...');
            
            try {
                // Simulate offline mode
                const queueStart = performance.now();
                await simulateOfflineQueue(10);
                const queueTime = performance.now() - queueStart;
                
                const success = queueTime < 1000; // Quick queue operations
                logTestResult('Offline Queue Test', success, `${Math.round(queueTime)}ms`);
                
                if (success) testState.passedTests++;
                else testState.failedTests++;
                
            } catch (error) {
                logTestResult('Offline Queue Test', false, error.message);
                testState.failedTests++;
            }
        }

        async function runRateLimitTest() {
            log('‚è±Ô∏è Testing rate limit compliance...');
            
            try {
                const rateLimitStart = performance.now();
                
                // Test rate limiting behavior
                await simulateRateLimiting();
                
                const rateLimitTime = performance.now() - rateLimitStart;
                const success = rateLimitTime > 3000; // Should take time due to rate limiting
                
                logTestResult('Rate Limit Test', success, `${Math.round(rateLimitTime)}ms (should be >3s)`);
                
                if (success) testState.passedTests++;
                else testState.failedTests++;
                
            } catch (error) {
                logTestResult('Rate Limit Test', false, error.message);
                testState.failedTests++;
            }
        }

        async function runBrowserCompatTest() {
            log('üåç Testing browser compatibility...');
            
            try {
                const compatResults = [];
                
                // Test localStorage
                try {
                    localStorage.setItem('test', 'value');
                    localStorage.removeItem('test');
                    compatResults.push('localStorage: ‚úÖ');
                } catch (e) {
                    compatResults.push('localStorage: ‚ùå');
                }
                
                // Test CSS Grid
                const testEl = document.createElement('div');
                testEl.style.display = 'grid';
                const hasGrid = testEl.style.display === 'grid';
                compatResults.push(`CSS Grid: ${hasGrid ? '‚úÖ' : '‚ùå'}`);
                
                // Test Fetch API
                const hasFetch = typeof fetch !== 'undefined';
                compatResults.push(`Fetch API: ${hasFetch ? '‚úÖ' : '‚ùå'}`);
                
                // Test ES6 features
                try {
                    eval('const test = () => {}; [1,2,3].map(x => x)');
                    compatResults.push('ES6: ‚úÖ');
                } catch (e) {
                    compatResults.push('ES6: ‚ùå');
                }
                
                const successCount = compatResults.filter(r => r.includes('‚úÖ')).length;
                const success = successCount >= 3;
                
                logTestResult('Browser Compatibility', success, compatResults.join(', '));
                
                if (success) testState.passedTests++;
                else testState.failedTests++;
                
            } catch (error) {
                logTestResult('Browser Compatibility', false, error.message);
                testState.failedTests++;
            }
        }

        async function runResponsiveTest() {
            log('üì± Testing responsive design...');
            
            try {
                const originalWidth = window.innerWidth;
                const tests = [];
                
                // Test various viewport sizes
                const viewports = [320, 768, 1024, 1920];
                
                for (const width of viewports) {
                    // Simulate viewport change
                    const elements = document.querySelectorAll('.test-section');
                    const isResponsive = elements.length > 0;
                    tests.push(isResponsive);
                }
                
                const success = tests.every(t => t);
                logTestResult('Responsive Design', success, `Tested ${viewports.length} viewport sizes`);
                
                if (success) testState.passedTests++;
                else testState.failedTests++;
                
            } catch (error) {
                logTestResult('Responsive Design', false, error.message);
                testState.failedTests++;
            }
        }

        async function runA11yTest() {
            log('‚ôø Running accessibility audit...');
            
            try {
                const a11yTests = [];
                
                // Test ARIA labels
                const buttonsWithAria = document.querySelectorAll('button[aria-label]').length;
                const totalButtons = document.querySelectorAll('button').length;
                a11yTests.push(buttonsWithAria >= totalButtons * 0.8);
                
                // Test heading hierarchy
                const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
                a11yTests.push(headings.length > 0);
                
                // Test color contrast (basic check)
                const hasHighContrastOption = document.querySelector('[data-theme="high-contrast"]') !== null;
                a11yTests.push(hasHighContrastOption);
                
                // Test keyboard navigation
                const focusableElements = document.querySelectorAll('button, input, select, textarea, [tabindex]');
                a11yTests.push(focusableElements.length > 0);
                
                // Test skip links
                const skipLinks = document.querySelectorAll('.skip-nav, .sr-only').length;
                a11yTests.push(skipLinks > 0);
                
                const passedA11yTests = a11yTests.filter(Boolean).length;
                const success = passedA11yTests >= 4;
                
                logTestResult('Accessibility Audit', success, `${passedA11yTests}/5 checks passed`);
                
                if (success) testState.passedTests++;
                else testState.failedTests++;
                
            } catch (error) {
                logTestResult('Accessibility Audit', false, error.message);
                testState.failedTests++;
            }
        }

        // Simulation functions
        async function simulateImport(data, type) {
            return new Promise(resolve => {
                // Simulate processing time based on data size
                const processingTime = Math.max(100, data.length / 1000);
                setTimeout(() => {
                    resolve(data.length);
                }, processingTime);
            });
        }

        async function simulateProcessing(data) {
            return new Promise(resolve => {
                setTimeout(() => {
                    // Simulate 95% success rate
                    const processed = Math.floor(data.length * 0.95);
                    resolve(processed);
                }, 100);
            });
        }

        async function simulateDataLoad(count) {
            return new Promise(resolve => {
                const loadTime = Math.max(50, count * 2);
                setTimeout(resolve, loadTime);
            });
        }

        async function simulateSearch(data, query) {
            return new Promise(resolve => {
                // Simulate search through data
                const searchTime = Math.max(10, data.length / 10);
                setTimeout(() => {
                    const results = data.filter(item => 
                        item.title.toLowerCase().includes(query.toLowerCase()) ||
                        item.tags.toLowerCase().includes(query.toLowerCase())
                    );
                    resolve(results);
                }, searchTime);
            });
        }

        async function simulateRender(itemCount) {
            return new Promise(resolve => {
                // Create DOM elements to simulate rendering
                const container = document.createElement('div');
                for (let i = 0; i < itemCount; i++) {
                    const item = document.createElement('div');
                    item.innerHTML = `<h3>Item ${i}</h3><p>Content for item ${i}</p>`;
                    container.appendChild(item);
                }
                
                // Simulate DOM manipulation time
                setTimeout(() => {
                    container.remove();
                    resolve(itemCount);
                }, 50);
            });
        }

        async function simulateAPICall() {
            return new Promise((resolve, reject) => {
                // Simulate API call with random success/failure
                const delay = 100 + Math.random() * 500;
                setTimeout(() => {
                    if (Math.random() > 0.1) { // 90% success rate
                        resolve({ success: true, data: 'mock data' });
                    } else {
                        reject(new Error('API call failed'));
                    }
                }, delay);
            });
        }

        async function simulateOfflineQueue(itemCount) {
            return new Promise(resolve => {
                // Simulate queue operations
                const queue = [];
                for (let i = 0; i < itemCount; i++) {
                    queue.push({ id: i, type: 'pmid', identifier: `${1000000 + i}` });
                }
                
                setTimeout(() => {
                    resolve(queue.length);
                }, 50);
            });
        }

        async function simulateRateLimiting() {
            return new Promise(resolve => {
                // Simulate rate-limited API calls (should take time)
                const calls = [];
                for (let i = 0; i < 10; i++) {
                    calls.push(new Promise(res => setTimeout(res, 300))); // 300ms between calls
                }
                
                Promise.all(calls).then(resolve);
            });
        }

        // Helper functions
        function convertToCSV(data) {
            const headers = ['PMID', 'DOI', 'Title', 'Authors', 'Journal', 'Year', 'Priority', 'Status', 'Tags', 'Notes'];
            let csv = headers.join(',') + '\n';
            
            data.forEach(record => {
                const row = [
                    record.pmid || '', record.doi || '', `"${record.title}"`, `"${record.authors}"`,
                    record.journal || '', record.year || '', record.priority || 'normal',
                    record.status || 'pending', `"${record.tags}"`, `"${record.notes}"`
                ];
                csv += row.join(',') + '\n';
            });
            
            return csv;
        }

        function updateProgress(percentage, message) {
            const progressBar = document.getElementById('main-progress');
            progressBar.style.width = `${percentage}%`;
            progressBar.textContent = message;
        }

        function updateMetrics() {
            document.getElementById('total-tests').textContent = `Tests: ${testState.passedTests + testState.failedTests}/${testState.totalTests}`;
            document.getElementById('passed-tests').textContent = `Passed: ${testState.passedTests}`;
            document.getElementById('failed-tests').textContent = `Failed: ${testState.failedTests}`;
            
            if (testState.startTime) {
                const runtime = Math.round((performance.now() - testState.startTime) / 1000);
                document.getElementById('runtime').textContent = `Runtime: ${runtime}s`;
            }
            
            // Update metric colors
            const passedEl = document.getElementById('passed-tests');
            const failedEl = document.getElementById('failed-tests');
            
            passedEl.className = testState.passedTests > 0 ? 'metric good' : 'metric';
            failedEl.className = testState.failedTests > 0 ? 'metric danger' : 'metric';
        }

        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}`;
            
            const resultsDiv = document.getElementById('detailed-results');
            resultsDiv.innerHTML += logMessage + '\n';
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
            
            console.log(logMessage);
        }

        function logTestResult(testName, passed, details) {
            const status = passed ? '‚úÖ PASS' : '‚ùå FAIL';
            const message = `${status} ${testName}: ${details}`;
            log(message);
            
            // Update specific test result areas
            const testSections = {
                'Massive CSV Import': 'massive-results',
                'Massive JSON Import': 'massive-results',
                'Mixed Identifier Test': 'massive-results',
                'Load Time Test': 'performance-results',
                'Search Performance': 'performance-results',
                'Render Performance': 'performance-results',
                'API Stress Test': 'api-results',
                'Offline Queue Test': 'api-results',
                'Rate Limit Test': 'api-results',
                'Browser Compatibility': 'browser-results',
                'Responsive Design': 'mobile-results',
                'Accessibility Audit': 'a11y-results'
            };
            
            const sectionId = testSections[testName];
            if (sectionId) {
                const section = document.getElementById(sectionId);
                const statusIndicator = passed ? '‚úÖ' : '‚ùå';
                const resultDiv = document.createElement('div');
                resultDiv.innerHTML = `${statusIndicator} ${testName}: ${details}`;
                resultDiv.style.color = passed ? '#27ae60' : '#e74c3c';
                resultDiv.style.fontWeight = 'bold';
                section.appendChild(resultDiv);
            }
        }

        function clearAllData() {
            if (confirm('Clear all test data and results? This cannot be undone.')) {
                testState.testData = [];
                testState.passedTests = 0;
                testState.failedTests = 0;
                testState.startTime = null;
                
                document.getElementById('detailed-results').innerHTML = 'Test results cleared...\n';
                document.getElementById('test-data-preview').textContent = 'Test data cleared...';
                
                // Clear all result sections
                ['massive-results', 'performance-results', 'api-results', 'browser-results', 'mobile-results', 'a11y-results'].forEach(id => {
                    const section = document.getElementById(id);
                    // Keep only the first 3 children (the info text)
                    while (section.children.length > 3) {
                        section.removeChild(section.lastChild);
                    }
                });
                
                updateProgress(0, 'Ready to start');
                updateMetrics();
                log('üßπ All test data and results cleared');
            }
        }

        function exportResults() {
            const results = {
                timestamp: new Date().toISOString(),
                summary: {
                    totalTests: testState.totalTests,
                    passedTests: testState.passedTests,
                    failedTests: testState.failedTests,
                    runtime: testState.startTime ? Math.round((performance.now() - testState.startTime) / 1000) : 0
                },
                browserInfo: {
                    userAgent: navigator.userAgent,
                    viewport: `${window.innerWidth}x${window.innerHeight}`,
                    memory: performance.memory ? Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + 'MB' : 'Unknown'
                },
                detailedResults: document.getElementById('detailed-results').textContent
            };
            
            const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `silentstacks-stress-test-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            log('üìÑ Test results exported successfully');
        }

        // Additional test functions for comprehensive coverage
        async function runTouchTargetTest() {
            log('üëÜ Testing touch target sizes...');
            
            try {
                const buttons = document.querySelectorAll('button');
                const inputs = document.querySelectorAll('input, select, textarea');
                const allTargets = [...buttons, ...inputs];
                
                let adequateTargets = 0;
                
                allTargets.forEach(target => {
                    const rect = target.getBoundingClientRect();
                    const size = Math.min(rect.width, rect.height);
                    if (size >= 44) { // WCAG AAA requirement
                        adequateTargets++;
                    }
                });
                
                const percentage = (adequateTargets / allTargets.length) * 100;
                const success = percentage >= 90;
                
                logTestResult('Touch Target Test', success, `${adequateTargets}/${allTargets.length} targets (${Math.round(percentage)}%) meet 44px minimum`);
                
                if (success) testState.passedTests++;
                else testState.failedTests++;
                
            } catch (error) {
                logTestResult('Touch Target Test', false, error.message);
                testState.failedTests++;
            }
        }

        async function runViewportTest() {
            log('üîÑ Testing viewport adaptation...');
            
            try {
                const initialViewport = `${window.innerWidth}x${window.innerHeight}`;
                
                // Test if layout adapts to different viewport sizes
                const testSizes = [
                    { width: 320, name: 'Mobile Portrait' },
                    { width: 768, name: 'Tablet' },
                    { width: 1024, name: 'Desktop' },
                    { width: 1920, name: 'Large Desktop' }
                ];
                
                let adaptationTests = 0;
                
                testSizes.forEach(size => {
                    // Simulate checking if layout elements adapt
                    const containers = document.querySelectorAll('.container, .test-grid');
                    const hasResponsiveClasses = Array.from(containers).some(el => 
                        getComputedStyle(el).display === 'grid' || 
                        getComputedStyle(el).display === 'flex'
                    );
                    
                    if (hasResponsiveClasses) adaptationTests++;
                });
                
                const success = adaptationTests >= 3;
                logTestResult('Viewport Test', success, `Layout adapts to ${adaptationTests}/${testSizes.length} viewport sizes`);
                
                if (success) testState.passedTests++;
                else testState.failedTests++;
                
            } catch (error) {
                logTestResult('Viewport Test', false, error.message);
                testState.failedTests++;
            }
        }

        async function runKeyboardTest() {
            log('‚å®Ô∏è Testing keyboard navigation...');
            
            try {
                const focusableElements = document.querySelectorAll(
                    'button:not([disabled]), input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])'
                );
                
                let keyboardAccessible = 0;
                
                focusableElements.forEach(element => {
                    // Check if element can receive focus
                    try {
                        element.focus();
                        if (document.activeElement === element) {
                            keyboardAccessible++;
                        }
                    } catch (e) {
                        // Element not focusable
                    }
                });
                
                const percentage = (keyboardAccessible / focusableElements.length) * 100;
                const success = percentage >= 95;
                
                logTestResult('Keyboard Navigation', success, `${keyboardAccessible}/${focusableElements.length} elements (${Math.round(percentage)}%) keyboard accessible`);
                
                if (success) testState.passedTests++;
                else testState.failedTests++;
                
            } catch (error) {
                logTestResult('Keyboard Navigation', false, error.message);
                testState.failedTests++;
            }
        }

        async function runContrastTest() {
            log('üé® Testing color contrast ratios...');
            
            try {
                // Basic contrast test by checking if high contrast theme exists
                const hasHighContrast = document.querySelector('link[href*="high-contrast"]') !== null ||
                                       document.querySelector('style').textContent.includes('high-contrast');
                
                // Check for contrast indicators in CSS
                const styles = Array.from(document.styleSheets).some(sheet => {
                    try {
                        return Array.from(sheet.cssRules).some(rule => 
                            rule.selectorText && rule.selectorText.includes('high-contrast')
                        );
                    } catch (e) {
                        return false;
                    }
                });
                
                const success = hasHighContrast || styles;
                logTestResult('Color Contrast', success, success ? 'High contrast theme available' : 'No high contrast theme found');
                
                if (success) testState.passedTests++;
                else testState.failedTests++;
                
            } catch (error) {
                logTestResult('Color Contrast', false, error.message);
                testState.failedTests++;
            }
        }

        async function runLocalStorageTest() {
            log('üíæ Testing localStorage limits and performance...');
            
            try {
                const testKey = 'silentstacks_storage_test';
                const largeData = new Array(10000).fill('test data ').join('');
                
                const writeStart = performance.now();
                localStorage.setItem(testKey, largeData);
                const writeTime = performance.now() - writeStart;
                
                const readStart = performance.now();
                const retrievedData = localStorage.getItem(testKey);
                const readTime = performance.now() - readStart;
                
                localStorage.removeItem(testKey);
                
                const success = writeTime < 100 && readTime < 50 && retrievedData === largeData;
                logTestResult('LocalStorage Test', success, `Write: ${Math.round(writeTime)}ms, Read: ${Math.round(readTime)}ms`);
                
                if (success) testState.passedTests++;
                else testState.failedTests++;
                
            } catch (error) {
                logTestResult('LocalStorage Test', false, error.message);
                testState.failedTests++;
            }
        }

        async function runCSSCompatTest() {
            log('üé® Testing CSS feature compatibility...');
            
            try {
                const testElement = document.createElement('div');
                document.body.appendChild(testElement);
                
                const features = {
                    'CSS Grid': () => {
                        testElement.style.display = 'grid';
                        return getComputedStyle(testElement).display === 'grid';
                    },
                    'CSS Flexbox': () => {
                        testElement.style.display = 'flex';
                        return getComputedStyle(testElement).display === 'flex';
                    },
                    'CSS Variables': () => {
                        testElement.style.setProperty('--test-var', 'test');
                        return testElement.style.getPropertyValue('--test-var') === 'test';
                    },
                    'CSS Transforms': () => {
                        testElement.style.transform = 'translateX(10px)';
                        return testElement.style.transform === 'translateX(10px)';
                    }
                };
                
                const results = Object.entries(features).map(([name, test]) => {
                    try {
                        return { name, supported: test() };
                    } catch {
                        return { name, supported: false };
                    }
                });
                
                document.body.removeChild(testElement);
                
                const supportedCount = results.filter(r => r.supported).length;
                const success = supportedCount >= 3;
                
                const details = results.map(r => `${r.name}: ${r.supported ? '‚úÖ' : '‚ùå'}`).join(', ');
                logTestResult('CSS Compatibility', success, details);
                
                if (success) testState.passedTests++;
                else testState.failedTests++;
                
            } catch (error) {
                logTestResult('CSS Compatibility', false, error.message);
                testState.failedTests++;
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            initPerformanceMonitoring();
            log('üß™ Stress Testing Suite initialized');
            log('üí° Click "Generate Test Data" to create 1000 test records');
            log('üöÄ Click "Run All Tests" to begin comprehensive testing');
        });

        // Add cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (performanceInterval) {
                clearInterval(performanceInterval);
            }
        });
    </script>
</body>
</html>
