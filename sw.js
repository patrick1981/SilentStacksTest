const CACHE_NAME='silentstacks-v2.0';const CACHE_VERSION='2.0.0';const FULL_CACHE_NAME=`${ CACHE_NAME }-${ CACHE_VERSION }`;const STATIC_CACHE_FILES=['./','./index.html','./dependencies.min.js','./app.min.js','./fonts/main-regular.woff','./fonts/main-bold.woff'];const API_CACHE_PATTERNS=[/eutils\.ncbi\.nlm\.nih\.gov/,/api\.crossref\.org/,/clinicaltrials\.gov/];const API_CACHE_DURATION=7*24*60*60*1000;self.addEventListener('install',event=>{console.log('[SW] Installing SilentStacks Service Worker v2.0');event.waitUntil(caches.open(FULL_CACHE_NAME).then(cache=>{console.log('[SW] Caching app shell files');return cache.addAll(STATIC_CACHE_FILES)}).then(()=>{console.log('[SW] App shell cached successfully');return self.skipWaiting()}).catch(error=>{console.warn('[SW] Failed to cache some files:',error);}))});self.addEventListener('activate',event=>{console.log('[SW] Activating SilentStacks Service Worker v2.0');event.waitUntil(caches.keys().then(cacheNames=>{return Promise.all(cacheNames.map(cacheName=>{if(cacheName.startsWith(CACHE_NAME)&&cacheName!==FULL_CACHE_NAME){console.log('[SW] Deleting old cache:',cacheName);return caches.delete(cacheName)}}))}).then(()=>{console.log('[SW] Service Worker activated');return self.clients.claim()}))});self.addEventListener('fetch',event=>{const url=new URL(event.request.url);if(event.request.method!=='GET'){return}if(isStaticAsset(url)){event.respondWith(cacheFirst(event.request))}else if(isAPIRequest(url)){event.respondWith(networkFirstWithTimeout(event.request,4000))}else{return}});function isStaticAsset(url){if(url.origin===location.origin){const pathname=url.pathname;return pathname==='/'||pathname.endsWith('.html')||pathname.endsWith('.js')||pathname.endsWith('.woff')||pathname.endsWith('.css')}return false}function isAPIRequest(url){return API_CACHE_PATTERNS.some(pattern=>pattern.test(url.host))}async function cacheFirst(request){try{const cachedResponse=await caches.match(request);if(cachedResponse){return cachedResponse}const networkResponse=await fetch(request);if(networkResponse.ok){const cache=await caches.open(FULL_CACHE_NAME);cache.put(request,networkResponse.clone())}return networkResponse}catch(error){console.warn('[SW] Cache first failed:',error);throw error}}async function networkFirstWithTimeout(request,timeout=4000){try{const controller=new AbortController();const timeoutId=setTimeout(()=>controller.abort(),timeout);const networkResponse=await fetch(request,{signal:controller.signal});clearTimeout(timeoutId);if(networkResponse.ok){const cache=await caches.open(FULL_CACHE_NAME);const responseClone=networkResponse.clone();const responseWithTimestamp=new Response(responseClone.body,{status:responseClone.status,statusText:responseClone.statusText,headers:{...Object.fromEntries(responseClone.headers.entries()),'sw-cached-at':Date.now().toString()}});cache.put(request,responseWithTimestamp)}return networkResponse}catch(error){console.log('[SW] Network failed, trying cache:',error.message);const cachedResponse=await caches.match(request);if(cachedResponse){const cachedAt=cachedResponse.headers.get('sw-cached-at');if(cachedAt){const age=Date.now()-parseInt(cachedAt);if(age>API_CACHE_DURATION){console.log('[SW] Cached API response expired');}}console.log('[SW] Serving from cache (offline)');return cachedResponse}throw new Error('Network unavailable and no cached response')}}self.addEventListener('sync',event=>{console.log('[SW] Background sync:',event.tag);if(event.tag==='background-sync-requests'){event.waitUntil(syncPendingRequests())}});async function syncPendingRequests(){try{console.log('[SW] Syncing pending requests...');const clients=await self.clients.matchAll();clients.forEach(client=>{client.postMessage({type:'BACKGROUND_SYNC',status:'syncing'})});}catch(error){console.warn('[SW] Background sync failed:',error)}}self.addEventListener('message',event=>{console.log('[SW] Message received:',event.data);switch(event.data.type){case 'SKIP_WAITING':self.skipWaiting();break;case 'GET_VERSION':event.ports[0].postMessage({version:CACHE_VERSION,cacheSize:getCacheSize()});break;case 'CLEAR_CACHE':clearAppCache().then(()=>{event.ports[0].postMessage({success:true})});break}});async function getCacheSize(){try{const cache=await caches.open(FULL_CACHE_NAME);const keys=await cache.keys();return keys.length}catch(error){return 0}}async function clearAppCache(){try{const cacheNames=await caches.keys();await Promise.all(cacheNames.filter(name=>name.startsWith(CACHE_NAME)).map(name=>caches.delete(name)));console.log('[SW] App cache cleared')}catch(error){console.warn('[SW] Failed to clear cache:',error)}}console.log('[SW] SilentStacks Service Worker v2.0 loaded');